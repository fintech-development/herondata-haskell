{-
   Heron Data API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.0
   Heron Data API API version: 2021-07-19
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

-- |
-- Module : HeronData.Model
module HeronData.Model where

import Control.Applicative (Alternative, (<|>))
import qualified Control.Arrow as P (left)
import Data.Aeson ((.!=), (.:), (.:!), (.:?), (.=))
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (TypeRep, Typeable, typeOf, typeRep)
import qualified Data.Foldable as P
import Data.Function ((&))
import Data.Functor ((<&>))
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import Data.Monoid ((<>))
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import HeronData.Core
import HeronData.MimeTypes
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH
import Prelude (Applicative, Bool (..), Char, Double, FilePath, Float, Functor, Int, Integer, Maybe (..), Monad, String, fmap, maybe, mempty, pure, undefined, ($), (.), (/=), (<$>), (<*>), (=<<), (>>=))
import qualified Prelude as P

-- * Parameter newtypes

-- ** AccountId

newtype AccountId = AccountId {unAccountId :: Text} deriving (P.Eq, P.Show)

-- ** CategoryHeronId

newtype CategoryHeronId = CategoryHeronId {unCategoryHeronId :: Text} deriving (P.Eq, P.Show)

-- ** CategoryHeronIdText

newtype CategoryHeronIdText = CategoryHeronIdText {unCategoryHeronIdText :: [Text]} deriving (P.Eq, P.Show)

-- ** CategoryHeronIds

newtype CategoryHeronIds = CategoryHeronIds {unCategoryHeronIds :: [Text]} deriving (P.Eq, P.Show)

-- ** CategoryLabel

newtype CategoryLabel = CategoryLabel {unCategoryLabel :: Text} deriving (P.Eq, P.Show)

-- ** ConfidenceMax

newtype ConfidenceMax = ConfidenceMax {unConfidenceMax :: Double} deriving (P.Eq, P.Show)

-- ** ConfidenceMin

newtype ConfidenceMin = ConfidenceMin {unConfidenceMin :: Double} deriving (P.Eq, P.Show)

-- ** CreatedDateMax

newtype CreatedDateMax = CreatedDateMax {unCreatedDateMax :: Date} deriving (P.Eq, P.Show)

-- ** CreatedDateMin

newtype CreatedDateMin = CreatedDateMin {unCreatedDateMin :: Date} deriving (P.Eq, P.Show)

-- ** DateGranularity

newtype DateGranularity = DateGranularity {unDateGranularity :: E'DateGranularity} deriving (P.Eq, P.Show)

-- ** DateGranularity2

newtype DateGranularity2 = DateGranularity2 {unDateGranularity2 :: E'DateGranularity2} deriving (P.Eq, P.Show)

-- ** DescriptionKeyword

newtype DescriptionKeyword = DescriptionKeyword {unDescriptionKeyword :: Text} deriving (P.Eq, P.Show)

-- ** DescriptionRegex

newtype DescriptionRegex = DescriptionRegex {unDescriptionRegex :: Text} deriving (P.Eq, P.Show)

-- ** EndUserHeronId

newtype EndUserHeronId = EndUserHeronId {unEndUserHeronId :: Text} deriving (P.Eq, P.Show)

-- ** EndUserId

newtype EndUserId = EndUserId {unEndUserId :: Text} deriving (P.Eq, P.Show)

-- ** FromDate

newtype FromDate = FromDate {unFromDate :: Date} deriving (P.Eq, P.Show)

-- ** GroupBy

newtype GroupBy = GroupBy {unGroupBy :: E'GroupBy} deriving (P.Eq, P.Show)

-- ** HasMatchingTransaction

newtype HasMatchingTransaction = HasMatchingTransaction {unHasMatchingTransaction :: Bool} deriving (P.Eq, P.Show)

-- ** HeronId

newtype HeronId = HeronId {unHeronId :: Text} deriving (P.Eq, P.Show)

-- ** IncludeDuplicates

newtype IncludeDuplicates = IncludeDuplicates {unIncludeDuplicates :: Bool} deriving (P.Eq, P.Show)

-- ** IsRecurring

newtype IsRecurring = IsRecurring {unIsRecurring :: Bool} deriving (P.Eq, P.Show)

-- ** LastUpdatedMax

newtype LastUpdatedMax = LastUpdatedMax {unLastUpdatedMax :: DateTime} deriving (P.Eq, P.Show)

-- ** LastUpdatedMin

newtype LastUpdatedMin = LastUpdatedMin {unLastUpdatedMin :: DateTime} deriving (P.Eq, P.Show)

-- ** Limit

newtype Limit = Limit {unLimit :: Int} deriving (P.Eq, P.Show)

-- ** MaxAmount

newtype MaxAmount = MaxAmount {unMaxAmount :: Double} deriving (P.Eq, P.Show)

-- ** MerchantHeronIds

newtype MerchantHeronIds = MerchantHeronIds {unMerchantHeronIds :: [Text]} deriving (P.Eq, P.Show)

-- ** MinAmount

newtype MinAmount = MinAmount {unMinAmount :: Double} deriving (P.Eq, P.Show)

-- ** Name

newtype Name = Name {unName :: Text} deriving (P.Eq, P.Show)

-- ** OnlyDuplicates

newtype OnlyDuplicates = OnlyDuplicates {unOnlyDuplicates :: Bool} deriving (P.Eq, P.Show)

-- ** OrderBy

newtype OrderBy = OrderBy {unOrderBy :: E'OrderBy} deriving (P.Eq, P.Show)

-- ** OrderBy2

newtype OrderBy2 = OrderBy2 {unOrderBy2 :: E'OrderBy2} deriving (P.Eq, P.Show)

-- ** Page

newtype Page = Page {unPage :: Int} deriving (P.Eq, P.Show)

-- ** ReferenceId

newtype ReferenceId = ReferenceId {unReferenceId :: Text} deriving (P.Eq, P.Show)

-- ** RequestId

newtype RequestId = RequestId {unRequestId :: Text} deriving (P.Eq, P.Show)

-- ** Status

newtype Status = Status {unStatus :: E'Status} deriving (P.Eq, P.Show)

-- ** TimestampDateMax

newtype TimestampDateMax = TimestampDateMax {unTimestampDateMax :: Date} deriving (P.Eq, P.Show)

-- ** TimestampDateMin

newtype TimestampDateMin = TimestampDateMin {unTimestampDateMin :: Date} deriving (P.Eq, P.Show)

-- ** TimestampMax

newtype TimestampMax = TimestampMax {unTimestampMax :: DateTime} deriving (P.Eq, P.Show)

-- ** TimestampMin

newtype TimestampMin = TimestampMin {unTimestampMin :: DateTime} deriving (P.Eq, P.Show)

-- ** ToDate

newtype ToDate = ToDate {unToDate :: Date} deriving (P.Eq, P.Show)

-- ** TransactionCode

newtype TransactionCode = TransactionCode {unTransactionCode :: Text} deriving (P.Eq, P.Show)

-- * Models

-- ** Category

-- | Category
data Category = Category
  { -- | /ReadOnly/ "created" - Timestamp for when the category was created
    categoryCreated :: !(Maybe DateTime),
    -- | "description"
    categoryDescription :: !(Maybe Text),
    -- | /ReadOnly/ "heron_id" - Unique ID of the category generated by Heron Data
    categoryHeronId :: !(Maybe Text),
    -- | /Required/ "label" - The label of the category
    categoryLabel :: !(Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Category
instance A.FromJSON Category where
  parseJSON = A.withObject "Category" $ \o ->
    Category
      <$> (o .:? "created")
      <*> (o .:? "description")
      <*> (o .:? "heron_id")
      <*> (o .: "label")

-- | ToJSON Category
instance A.ToJSON Category where
  toJSON Category {..} =
    A.object
      [ "created" .= categoryCreated,
        "description" .= categoryDescription,
        "heron_id" .= categoryHeronId,
        "label" .= categoryLabel
      ]

-- | Construct a value of type 'Category' (by applying it's required fields, if any)
mkCategory ::
  -- | 'categoryLabel': The label of the category
  Text ->
  Category
mkCategory categoryLabel =
  Category
    { categoryCreated = Nothing,
      categoryDescription = Nothing,
      categoryHeronId = Nothing,
      categoryLabel
    }

-- ** CategoryFeedback

-- | CategoryFeedback
data CategoryFeedback = CategoryFeedback
  { -- | "heron_id"
    categoryFeedbackHeronId :: !(Maybe Text),
    -- | "label"
    categoryFeedbackLabel :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CategoryFeedback
instance A.FromJSON CategoryFeedback where
  parseJSON = A.withObject "CategoryFeedback" $ \o ->
    CategoryFeedback
      <$> (o .:? "heron_id")
      <*> (o .:? "label")

-- | ToJSON CategoryFeedback
instance A.ToJSON CategoryFeedback where
  toJSON CategoryFeedback {..} =
    A.object
      [ "heron_id" .= categoryFeedbackHeronId,
        "label" .= categoryFeedbackLabel
      ]

-- | Construct a value of type 'CategoryFeedback' (by applying it's required fields, if any)
mkCategoryFeedback ::
  CategoryFeedback
mkCategoryFeedback =
  CategoryFeedback
    { categoryFeedbackHeronId = Nothing,
      categoryFeedbackLabel = Nothing
    }

-- ** DeleteTransactionParams

-- | DeleteTransactionParams
data DeleteTransactionParams = DeleteTransactionParams
  { -- | "account_id"
    deleteTransactionParamsAccountId :: !(Maybe Text),
    -- | "end_user_id"
    deleteTransactionParamsEndUserId :: !(Maybe Text),
    -- | "heron_id"
    deleteTransactionParamsHeronId :: !(Maybe Text),
    -- | "only_duplicates" - if true, deletes only duplicates
    deleteTransactionParamsOnlyDuplicates :: !(Maybe Bool),
    -- | "request_id"
    deleteTransactionParamsRequestId :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteTransactionParams
instance A.FromJSON DeleteTransactionParams where
  parseJSON = A.withObject "DeleteTransactionParams" $ \o ->
    DeleteTransactionParams
      <$> (o .:? "account_id")
      <*> (o .:? "end_user_id")
      <*> (o .:? "heron_id")
      <*> (o .:? "only_duplicates")
      <*> (o .:? "request_id")

-- | ToJSON DeleteTransactionParams
instance A.ToJSON DeleteTransactionParams where
  toJSON DeleteTransactionParams {..} =
    A.object
      [ "account_id" .= deleteTransactionParamsAccountId,
        "end_user_id" .= deleteTransactionParamsEndUserId,
        "heron_id" .= deleteTransactionParamsHeronId,
        "only_duplicates" .= deleteTransactionParamsOnlyDuplicates,
        "request_id" .= deleteTransactionParamsRequestId
      ]

-- | Construct a value of type 'DeleteTransactionParams' (by applying it's required fields, if any)
mkDeleteTransactionParams ::
  DeleteTransactionParams
mkDeleteTransactionParams =
  DeleteTransactionParams
    { deleteTransactionParamsAccountId = Nothing,
      deleteTransactionParamsEndUserId = Nothing,
      deleteTransactionParamsHeronId = Nothing,
      deleteTransactionParamsOnlyDuplicates = Nothing,
      deleteTransactionParamsRequestId = Nothing
    }

-- ** EndUser

-- | EndUser
data EndUser = EndUser
  { -- | /ReadOnly/ "confidence" - Aggregated confidence for the end user across all transactions; between 0 and 1
    endUserConfidence :: !(Maybe Double),
    -- | /ReadOnly/ "created" - When the end user was created in Heron system
    endUserCreated :: !(Maybe DateTime),
    -- | /ReadOnly/ "criteria" - Information about an end user that can be used as rules for underwriting
    endUserCriteria :: !(Maybe A.Value),
    -- | /Required/ "end_user_id" - id defined by user; links to the end_user_id for transactions
    endUserEndUserId :: !(Text),
    -- | /ReadOnly/ "heron_id" - Unique id for end user generated by Heron
    endUserHeronId :: !(Maybe Text),
    -- | /ReadOnly/ "last_updated" - When the end user was last updated in Heron system
    endUserLastUpdated :: !(Maybe DateTime),
    -- | "name" - Name of end user; may help to improve categorisation accuracy
    endUserName :: !(Maybe Text),
    -- | /Required/ "status" - Status of end user; &#39;ready&#39; triggers async processing, &#39;review_requested&#39; triggers manual review request
    endUserStatus :: !(E'Status)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndUser
instance A.FromJSON EndUser where
  parseJSON = A.withObject "EndUser" $ \o ->
    EndUser
      <$> (o .:? "confidence")
      <*> (o .:? "created")
      <*> (o .:? "criteria")
      <*> (o .: "end_user_id")
      <*> (o .:? "heron_id")
      <*> (o .:? "last_updated")
      <*> (o .:? "name")
      <*> (o .: "status")

-- | ToJSON EndUser
instance A.ToJSON EndUser where
  toJSON EndUser {..} =
    A.object
      [ "confidence" .= endUserConfidence,
        "created" .= endUserCreated,
        "criteria" .= endUserCriteria,
        "end_user_id" .= endUserEndUserId,
        "heron_id" .= endUserHeronId,
        "last_updated" .= endUserLastUpdated,
        "name" .= endUserName,
        "status" .= endUserStatus
      ]

-- | Construct a value of type 'EndUser' (by applying it's required fields, if any)
mkEndUser ::
  -- | 'endUserEndUserId': id defined by user; links to the end_user_id for transactions
  Text ->
  -- | 'endUserStatus': Status of end user; 'ready' triggers async processing, 'review_requested' triggers manual review request
  E'Status ->
  EndUser
mkEndUser endUserEndUserId endUserStatus =
  EndUser
    { endUserConfidence = Nothing,
      endUserCreated = Nothing,
      endUserCriteria = Nothing,
      endUserEndUserId,
      endUserHeronId = Nothing,
      endUserLastUpdated = Nothing,
      endUserName = Nothing,
      endUserStatus
    }

-- ** EndUserBalanceInputParams

-- | EndUserBalanceInputParams
data EndUserBalanceInputParams = EndUserBalanceInputParams
  { -- | "end_user_heron_id" - Heron-generated id for end user; either end_user_id or end_user_heron_id is required
    endUserBalanceInputParamsEndUserHeronId :: !(Maybe Text),
    -- | "end_user_id" - end_user_id for statistics; either end_user_id or end_user_heron_id is required
    endUserBalanceInputParamsEndUserId :: !(Maybe Text),
    -- | "timestamp_max" - Filter for transactions with timestamp earlier than the input value
    endUserBalanceInputParamsTimestampMax :: !(Maybe DateTime),
    -- | "timestamp_min" - Filter for transactions with timestamp after the input value
    endUserBalanceInputParamsTimestampMin :: !(Maybe DateTime)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndUserBalanceInputParams
instance A.FromJSON EndUserBalanceInputParams where
  parseJSON = A.withObject "EndUserBalanceInputParams" $ \o ->
    EndUserBalanceInputParams
      <$> (o .:? "end_user_heron_id")
      <*> (o .:? "end_user_id")
      <*> (o .:? "timestamp_max")
      <*> (o .:? "timestamp_min")

-- | ToJSON EndUserBalanceInputParams
instance A.ToJSON EndUserBalanceInputParams where
  toJSON EndUserBalanceInputParams {..} =
    A.object
      [ "end_user_heron_id" .= endUserBalanceInputParamsEndUserHeronId,
        "end_user_id" .= endUserBalanceInputParamsEndUserId,
        "timestamp_max" .= endUserBalanceInputParamsTimestampMax,
        "timestamp_min" .= endUserBalanceInputParamsTimestampMin
      ]

-- | Construct a value of type 'EndUserBalanceInputParams' (by applying it's required fields, if any)
mkEndUserBalanceInputParams ::
  EndUserBalanceInputParams
mkEndUserBalanceInputParams =
  EndUserBalanceInputParams
    { endUserBalanceInputParamsEndUserHeronId = Nothing,
      endUserBalanceInputParamsEndUserId = Nothing,
      endUserBalanceInputParamsTimestampMax = Nothing,
      endUserBalanceInputParamsTimestampMin = Nothing
    }

-- ** EndUserForecastInputParams

-- | EndUserForecastInputParams
data EndUserForecastInputParams = EndUserForecastInputParams
  { -- | "category_heron_id" - Heron ID of category to be forecasted; either category_heron_id or category_label must be present
    endUserForecastInputParamsCategoryHeronId :: !(Maybe Text),
    -- | "category_label" - Label of category to be forecasted; either category_heron_id or category_label must be present
    endUserForecastInputParamsCategoryLabel :: !(Maybe Text),
    -- | "date_granularity" - Aggregate results over time, i.e., aggregate by week or by month
    endUserForecastInputParamsDateGranularity :: !(Maybe E'DateGranularity),
    -- | "end_user_heron_id" - Heron-generated id for end user; either end_user_id or end_user_heron_id is required
    endUserForecastInputParamsEndUserHeronId :: !(Maybe Text),
    -- | "end_user_id" - end_user_id for statistics; either end_user_id or end_user_heron_id is required
    endUserForecastInputParamsEndUserId :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndUserForecastInputParams
instance A.FromJSON EndUserForecastInputParams where
  parseJSON = A.withObject "EndUserForecastInputParams" $ \o ->
    EndUserForecastInputParams
      <$> (o .:? "category_heron_id")
      <*> (o .:? "category_label")
      <*> (o .:? "date_granularity")
      <*> (o .:? "end_user_heron_id")
      <*> (o .:? "end_user_id")

-- | ToJSON EndUserForecastInputParams
instance A.ToJSON EndUserForecastInputParams where
  toJSON EndUserForecastInputParams {..} =
    A.object
      [ "category_heron_id" .= endUserForecastInputParamsCategoryHeronId,
        "category_label" .= endUserForecastInputParamsCategoryLabel,
        "date_granularity" .= endUserForecastInputParamsDateGranularity,
        "end_user_heron_id" .= endUserForecastInputParamsEndUserHeronId,
        "end_user_id" .= endUserForecastInputParamsEndUserId
      ]

-- | Construct a value of type 'EndUserForecastInputParams' (by applying it's required fields, if any)
mkEndUserForecastInputParams ::
  EndUserForecastInputParams
mkEndUserForecastInputParams =
  EndUserForecastInputParams
    { endUserForecastInputParamsCategoryHeronId = Nothing,
      endUserForecastInputParamsCategoryLabel = Nothing,
      endUserForecastInputParamsDateGranularity = Nothing,
      endUserForecastInputParamsEndUserHeronId = Nothing,
      endUserForecastInputParamsEndUserId = Nothing
    }

-- ** EndUserForecastOutputSchema

-- | EndUserForecastOutputSchema
data EndUserForecastOutputSchema = EndUserForecastOutputSchema
  { -- | "date" - Forecast date at specified date granularity
    endUserForecastOutputSchemaDate :: !(Maybe Text),
    -- | "predicted" - Predicted amount
    endUserForecastOutputSchemaPredicted :: !(Maybe Double),
    -- | "predicted_lower" - Predict amount lower bound
    endUserForecastOutputSchemaPredictedLower :: !(Maybe Double),
    -- | "predicted_upper" - Predicted amount upper bound
    endUserForecastOutputSchemaPredictedUpper :: !(Maybe Double)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndUserForecastOutputSchema
instance A.FromJSON EndUserForecastOutputSchema where
  parseJSON = A.withObject "EndUserForecastOutputSchema" $ \o ->
    EndUserForecastOutputSchema
      <$> (o .:? "date")
      <*> (o .:? "predicted")
      <*> (o .:? "predicted_lower")
      <*> (o .:? "predicted_upper")

-- | ToJSON EndUserForecastOutputSchema
instance A.ToJSON EndUserForecastOutputSchema where
  toJSON EndUserForecastOutputSchema {..} =
    A.object
      [ "date" .= endUserForecastOutputSchemaDate,
        "predicted" .= endUserForecastOutputSchemaPredicted,
        "predicted_lower" .= endUserForecastOutputSchemaPredictedLower,
        "predicted_upper" .= endUserForecastOutputSchemaPredictedUpper
      ]

-- | Construct a value of type 'EndUserForecastOutputSchema' (by applying it's required fields, if any)
mkEndUserForecastOutputSchema ::
  EndUserForecastOutputSchema
mkEndUserForecastOutputSchema =
  EndUserForecastOutputSchema
    { endUserForecastOutputSchemaDate = Nothing,
      endUserForecastOutputSchemaPredicted = Nothing,
      endUserForecastOutputSchemaPredictedLower = Nothing,
      endUserForecastOutputSchemaPredictedUpper = Nothing
    }

-- ** EndUserReadParams

-- | EndUserReadParams
data EndUserReadParams = EndUserReadParams
  { -- | /ReadOnly/ "criteria" - Information about the end user that can be used as rules for underwriting
    endUserReadParamsCriteria :: !(Maybe A.Value),
    -- | "end_user_id" - Filter by ID associated with end_user_id field in transactions
    endUserReadParamsEndUserId :: !(Maybe Text),
    -- | "heron_id" - Unique ID generated by Heron
    endUserReadParamsHeronId :: !(Maybe Text),
    -- | "limit" - Pagination limit per page
    endUserReadParamsLimit :: !(Maybe Int),
    -- | "name" - Filter by name associated with end user
    endUserReadParamsName :: !(Maybe Text),
    -- | "order_by" - Order to return end users by
    endUserReadParamsOrderBy :: !(Maybe E'OrderBy),
    -- | "page" - Pagination page number
    endUserReadParamsPage :: !(Maybe Int),
    -- | "status" - Filter by status of end user
    endUserReadParamsStatus :: !(Maybe E'Status)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndUserReadParams
instance A.FromJSON EndUserReadParams where
  parseJSON = A.withObject "EndUserReadParams" $ \o ->
    EndUserReadParams
      <$> (o .:? "criteria")
      <*> (o .:? "end_user_id")
      <*> (o .:? "heron_id")
      <*> (o .:? "limit")
      <*> (o .:? "name")
      <*> (o .:? "order_by")
      <*> (o .:? "page")
      <*> (o .:? "status")

-- | ToJSON EndUserReadParams
instance A.ToJSON EndUserReadParams where
  toJSON EndUserReadParams {..} =
    A.object
      [ "criteria" .= endUserReadParamsCriteria,
        "end_user_id" .= endUserReadParamsEndUserId,
        "heron_id" .= endUserReadParamsHeronId,
        "limit" .= endUserReadParamsLimit,
        "name" .= endUserReadParamsName,
        "order_by" .= endUserReadParamsOrderBy,
        "page" .= endUserReadParamsPage,
        "status" .= endUserReadParamsStatus
      ]

-- | Construct a value of type 'EndUserReadParams' (by applying it's required fields, if any)
mkEndUserReadParams ::
  EndUserReadParams
mkEndUserReadParams =
  EndUserReadParams
    { endUserReadParamsCriteria = Nothing,
      endUserReadParamsEndUserId = Nothing,
      endUserReadParamsHeronId = Nothing,
      endUserReadParamsLimit = Nothing,
      endUserReadParamsName = Nothing,
      endUserReadParamsOrderBy = Nothing,
      endUserReadParamsPage = Nothing,
      endUserReadParamsStatus = Nothing
    }

-- ** EndUserStatsInputParams

-- | EndUserStatsInputParams
data EndUserStatsInputParams = EndUserStatsInputParams
  { -- | "category_heron_ids" - Filter by specific categories
    endUserStatsInputParamsCategoryHeronIds :: !(Maybe [Text]),
    -- | "date_granularity" - Aggregate results over time, e.g., by week or by quarter
    endUserStatsInputParamsDateGranularity :: !(Maybe E'DateGranularity2),
    -- | "end_user_heron_id" - Heron-generated id for end user; either end_user_id or end_user_heron_id is required
    endUserStatsInputParamsEndUserHeronId :: !(Maybe Text),
    -- | "end_user_id" - end_user_id for statistics; either end_user_id or end_user_heron_id is required
    endUserStatsInputParamsEndUserId :: !(Maybe Text),
    -- | "from_date" - Filter for transactions with timestamp after the input value (as date)
    endUserStatsInputParamsFromDate :: !(Maybe Date),
    -- | "group_by" - Pivot results by merchant or by category
    endUserStatsInputParamsGroupBy :: !(Maybe E'GroupBy),
    -- | "merchant_heron_ids" - Filter by specific merchants
    endUserStatsInputParamsMerchantHeronIds :: !(Maybe [Text]),
    -- | "to_date" - Filter for transactions with timestamp before the input value (as date)
    endUserStatsInputParamsToDate :: !(Maybe Date)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndUserStatsInputParams
instance A.FromJSON EndUserStatsInputParams where
  parseJSON = A.withObject "EndUserStatsInputParams" $ \o ->
    EndUserStatsInputParams
      <$> (o .:? "category_heron_ids")
      <*> (o .:? "date_granularity")
      <*> (o .:? "end_user_heron_id")
      <*> (o .:? "end_user_id")
      <*> (o .:? "from_date")
      <*> (o .:? "group_by")
      <*> (o .:? "merchant_heron_ids")
      <*> (o .:? "to_date")

-- | ToJSON EndUserStatsInputParams
instance A.ToJSON EndUserStatsInputParams where
  toJSON EndUserStatsInputParams {..} =
    A.object
      [ "category_heron_ids" .= endUserStatsInputParamsCategoryHeronIds,
        "date_granularity" .= endUserStatsInputParamsDateGranularity,
        "end_user_heron_id" .= endUserStatsInputParamsEndUserHeronId,
        "end_user_id" .= endUserStatsInputParamsEndUserId,
        "from_date" .= endUserStatsInputParamsFromDate,
        "group_by" .= endUserStatsInputParamsGroupBy,
        "merchant_heron_ids" .= endUserStatsInputParamsMerchantHeronIds,
        "to_date" .= endUserStatsInputParamsToDate
      ]

-- | Construct a value of type 'EndUserStatsInputParams' (by applying it's required fields, if any)
mkEndUserStatsInputParams ::
  EndUserStatsInputParams
mkEndUserStatsInputParams =
  EndUserStatsInputParams
    { endUserStatsInputParamsCategoryHeronIds = Nothing,
      endUserStatsInputParamsDateGranularity = Nothing,
      endUserStatsInputParamsEndUserHeronId = Nothing,
      endUserStatsInputParamsEndUserId = Nothing,
      endUserStatsInputParamsFromDate = Nothing,
      endUserStatsInputParamsGroupBy = Nothing,
      endUserStatsInputParamsMerchantHeronIds = Nothing,
      endUserStatsInputParamsToDate = Nothing
    }

-- ** GetTransactionParams

-- | GetTransactionParams
data GetTransactionParams = GetTransactionParams
  { -- | "category_heron_id" - Filter by the heron_id of the category that the transaction is annotated with
    getTransactionParamsCategoryHeronId :: !(Maybe [Text]),
    -- | "confidence_max" - Filter by maximum confidence of annotation associated with transaction
    getTransactionParamsConfidenceMax :: !(Maybe Double),
    -- | "confidence_min" - Filter by minimum confidence of annotation associated with transaction
    getTransactionParamsConfidenceMin :: !(Maybe Double),
    -- | "created_date_max" - Filter by latest transaction upload date - when Heron received the transaction
    getTransactionParamsCreatedDateMax :: !(Maybe Date),
    -- | "created_date_min" - Filter by earliest transaction upload date - when Heron received the transaction
    getTransactionParamsCreatedDateMin :: !(Maybe Date),
    -- | "description_keyword" - Filter by keyword match on transaction description; case insensitive
    getTransactionParamsDescriptionKeyword :: !(Maybe Text),
    -- | "description_regex" - Filter by regex matching transaction description
    getTransactionParamsDescriptionRegex :: !(Maybe Text),
    -- | "end_user_id" - End user id of transaction
    getTransactionParamsEndUserId :: !(Maybe Text),
    -- | "from_date" - Deprecated; see created_date_ or timestamp_date_
    getTransactionParamsFromDate :: !(Maybe Date),
    -- | "has_matching_transaction" - Filter by whether the transaction has a matching transaction
    getTransactionParamsHasMatchingTransaction :: !(Maybe Bool),
    -- | "heron_id" - Heron generated Id of transaction
    getTransactionParamsHeronId :: !(Maybe Text),
    -- | "include_duplicates" - Whether or not to include duplicate transactions in the response. Defaults to false unless request_id is provided, in which case it defaults to true.
    getTransactionParamsIncludeDuplicates :: !(Maybe Bool),
    -- | "is_recurring" - Filter by whether the transaction is recurring
    getTransactionParamsIsRecurring :: !(Maybe Bool),
    -- | "last_updated_max" - Filter for transactions whose values were last updated in Heron systems before the specified input value
    getTransactionParamsLastUpdatedMax :: !(Maybe DateTime),
    -- | "last_updated_min" - Filter for transactions whose values were last updated in Heron systems after the specified input value
    getTransactionParamsLastUpdatedMin :: !(Maybe DateTime),
    -- | "limit" - Number of transactions to return per page
    getTransactionParamsLimit :: !(Maybe Int),
    -- | "max_amount" - Filter by maximum amount of transaction
    getTransactionParamsMaxAmount :: !(Maybe Double),
    -- | "min_amount" - Filter by minimum amount of transaction
    getTransactionParamsMinAmount :: !(Maybe Double),
    -- | "order_by" - What to order transactions by
    getTransactionParamsOrderBy :: !(Maybe E'OrderBy2),
    -- | "page" - Page of transaction to return
    getTransactionParamsPage :: !(Maybe Int),
    -- | "reference_id" - Reference Id of transaction
    getTransactionParamsReferenceId :: !(Maybe Text),
    -- | "request_id" - Request-Id header returned in the response of POST transactions. Sending this parameter will return all transactions sent in a particular POST request, including any duplicates.
    getTransactionParamsRequestId :: !(Maybe Text),
    -- | "timestamp_date_max" - Filter by latest transaction timestamp
    getTransactionParamsTimestampDateMax :: !(Maybe Date),
    -- | "timestamp_date_min" - Filter by earliest transaction timestamp
    getTransactionParamsTimestampDateMin :: !(Maybe Date),
    -- | "to_date" - Deprecated; see created_date_ or timestamp_date_
    getTransactionParamsToDate :: !(Maybe Date),
    -- | "transaction_code" - Filter by transaction code
    getTransactionParamsTransactionCode :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetTransactionParams
instance A.FromJSON GetTransactionParams where
  parseJSON = A.withObject "GetTransactionParams" $ \o ->
    GetTransactionParams
      <$> (o .:? "category_heron_id")
      <*> (o .:? "confidence_max")
      <*> (o .:? "confidence_min")
      <*> (o .:? "created_date_max")
      <*> (o .:? "created_date_min")
      <*> (o .:? "description_keyword")
      <*> (o .:? "description_regex")
      <*> (o .:? "end_user_id")
      <*> (o .:? "from_date")
      <*> (o .:? "has_matching_transaction")
      <*> (o .:? "heron_id")
      <*> (o .:? "include_duplicates")
      <*> (o .:? "is_recurring")
      <*> (o .:? "last_updated_max")
      <*> (o .:? "last_updated_min")
      <*> (o .:? "limit")
      <*> (o .:? "max_amount")
      <*> (o .:? "min_amount")
      <*> (o .:? "order_by")
      <*> (o .:? "page")
      <*> (o .:? "reference_id")
      <*> (o .:? "request_id")
      <*> (o .:? "timestamp_date_max")
      <*> (o .:? "timestamp_date_min")
      <*> (o .:? "to_date")
      <*> (o .:? "transaction_code")

-- | ToJSON GetTransactionParams
instance A.ToJSON GetTransactionParams where
  toJSON GetTransactionParams {..} =
    A.object
      [ "category_heron_id" .= getTransactionParamsCategoryHeronId,
        "confidence_max" .= getTransactionParamsConfidenceMax,
        "confidence_min" .= getTransactionParamsConfidenceMin,
        "created_date_max" .= getTransactionParamsCreatedDateMax,
        "created_date_min" .= getTransactionParamsCreatedDateMin,
        "description_keyword" .= getTransactionParamsDescriptionKeyword,
        "description_regex" .= getTransactionParamsDescriptionRegex,
        "end_user_id" .= getTransactionParamsEndUserId,
        "from_date" .= getTransactionParamsFromDate,
        "has_matching_transaction" .= getTransactionParamsHasMatchingTransaction,
        "heron_id" .= getTransactionParamsHeronId,
        "include_duplicates" .= getTransactionParamsIncludeDuplicates,
        "is_recurring" .= getTransactionParamsIsRecurring,
        "last_updated_max" .= getTransactionParamsLastUpdatedMax,
        "last_updated_min" .= getTransactionParamsLastUpdatedMin,
        "limit" .= getTransactionParamsLimit,
        "max_amount" .= getTransactionParamsMaxAmount,
        "min_amount" .= getTransactionParamsMinAmount,
        "order_by" .= getTransactionParamsOrderBy,
        "page" .= getTransactionParamsPage,
        "reference_id" .= getTransactionParamsReferenceId,
        "request_id" .= getTransactionParamsRequestId,
        "timestamp_date_max" .= getTransactionParamsTimestampDateMax,
        "timestamp_date_min" .= getTransactionParamsTimestampDateMin,
        "to_date" .= getTransactionParamsToDate,
        "transaction_code" .= getTransactionParamsTransactionCode
      ]

-- | Construct a value of type 'GetTransactionParams' (by applying it's required fields, if any)
mkGetTransactionParams ::
  GetTransactionParams
mkGetTransactionParams =
  GetTransactionParams
    { getTransactionParamsCategoryHeronId = Nothing,
      getTransactionParamsConfidenceMax = Nothing,
      getTransactionParamsConfidenceMin = Nothing,
      getTransactionParamsCreatedDateMax = Nothing,
      getTransactionParamsCreatedDateMin = Nothing,
      getTransactionParamsDescriptionKeyword = Nothing,
      getTransactionParamsDescriptionRegex = Nothing,
      getTransactionParamsEndUserId = Nothing,
      getTransactionParamsFromDate = Nothing,
      getTransactionParamsHasMatchingTransaction = Nothing,
      getTransactionParamsHeronId = Nothing,
      getTransactionParamsIncludeDuplicates = Nothing,
      getTransactionParamsIsRecurring = Nothing,
      getTransactionParamsLastUpdatedMax = Nothing,
      getTransactionParamsLastUpdatedMin = Nothing,
      getTransactionParamsLimit = Nothing,
      getTransactionParamsMaxAmount = Nothing,
      getTransactionParamsMinAmount = Nothing,
      getTransactionParamsOrderBy = Nothing,
      getTransactionParamsPage = Nothing,
      getTransactionParamsReferenceId = Nothing,
      getTransactionParamsRequestId = Nothing,
      getTransactionParamsTimestampDateMax = Nothing,
      getTransactionParamsTimestampDateMin = Nothing,
      getTransactionParamsToDate = Nothing,
      getTransactionParamsTransactionCode = Nothing
    }

-- ** InlineObject

-- | InlineObject
data InlineObject = InlineObject
  { -- | "end_user"
    inlineObjectEndUser :: !(Maybe EndUser)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject
instance A.FromJSON InlineObject where
  parseJSON = A.withObject "InlineObject" $ \o ->
    InlineObject
      <$> (o .:? "end_user")

-- | ToJSON InlineObject
instance A.ToJSON InlineObject where
  toJSON InlineObject {..} =
    A.object
      [ "end_user" .= inlineObjectEndUser
      ]

-- | Construct a value of type 'InlineObject' (by applying it's required fields, if any)
mkInlineObject ::
  InlineObject
mkInlineObject =
  InlineObject
    { inlineObjectEndUser = Nothing
    }

-- ** InlineObject1

-- | InlineObject1
data InlineObject1 = InlineObject1
  { -- | "end_user"
    inlineObject1EndUser :: !(Maybe EndUser)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject1
instance A.FromJSON InlineObject1 where
  parseJSON = A.withObject "InlineObject1" $ \o ->
    InlineObject1
      <$> (o .:? "end_user")

-- | ToJSON InlineObject1
instance A.ToJSON InlineObject1 where
  toJSON InlineObject1 {..} =
    A.object
      [ "end_user" .= inlineObject1EndUser
      ]

-- | Construct a value of type 'InlineObject1' (by applying it's required fields, if any)
mkInlineObject1 ::
  InlineObject1
mkInlineObject1 =
  InlineObject1
    { inlineObject1EndUser = Nothing
    }

-- ** InlineObject2

-- | InlineObject2
data InlineObject2 = InlineObject2
  { -- | "description"
    inlineObject2Description :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject2
instance A.FromJSON InlineObject2 where
  parseJSON = A.withObject "InlineObject2" $ \o ->
    InlineObject2
      <$> (o .:? "description")

-- | ToJSON InlineObject2
instance A.ToJSON InlineObject2 where
  toJSON InlineObject2 {..} =
    A.object
      [ "description" .= inlineObject2Description
      ]

-- | Construct a value of type 'InlineObject2' (by applying it's required fields, if any)
mkInlineObject2 ::
  InlineObject2
mkInlineObject2 =
  InlineObject2
    { inlineObject2Description = Nothing
    }

-- ** InlineObject3

-- | InlineObject3
data InlineObject3 = InlineObject3
  { -- | "transactions"
    inlineObject3Transactions :: !(Maybe [TransactionInput])
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject3
instance A.FromJSON InlineObject3 where
  parseJSON = A.withObject "InlineObject3" $ \o ->
    InlineObject3
      <$> (o .:? "transactions")

-- | ToJSON InlineObject3
instance A.ToJSON InlineObject3 where
  toJSON InlineObject3 {..} =
    A.object
      [ "transactions" .= inlineObject3Transactions
      ]

-- | Construct a value of type 'InlineObject3' (by applying it's required fields, if any)
mkInlineObject3 ::
  InlineObject3
mkInlineObject3 =
  InlineObject3
    { inlineObject3Transactions = Nothing
    }

-- ** InlineObject4

-- | InlineObject4
data InlineObject4 = InlineObject4
  { -- | "transaction"
    inlineObject4Transaction :: !(Maybe TransactionFeedbackSchema)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject4
instance A.FromJSON InlineObject4 where
  parseJSON = A.withObject "InlineObject4" $ \o ->
    InlineObject4
      <$> (o .:? "transaction")

-- | ToJSON InlineObject4
instance A.ToJSON InlineObject4 where
  toJSON InlineObject4 {..} =
    A.object
      [ "transaction" .= inlineObject4Transaction
      ]

-- | Construct a value of type 'InlineObject4' (by applying it's required fields, if any)
mkInlineObject4 ::
  InlineObject4
mkInlineObject4 =
  InlineObject4
    { inlineObject4Transaction = Nothing
    }

-- ** InlineResponse200

-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { -- | "categories"
    inlineResponse200Categories :: !(Maybe [Category])
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:? "categories")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
    A.object
      [ "categories" .= inlineResponse200Categories
      ]

-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200 ::
  InlineResponse200
mkInlineResponse200 =
  InlineResponse200
    { inlineResponse200Categories = Nothing
    }

-- ** InlineResponse2001

-- | InlineResponse2001
data InlineResponse2001 = InlineResponse2001
  { -- | "_meta"
    inlineResponse2001Meta :: !(Maybe InlineResponse2001Meta),
    -- | "end_users"
    inlineResponse2001EndUsers :: !(Maybe [EndUser])
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2001
instance A.FromJSON InlineResponse2001 where
  parseJSON = A.withObject "InlineResponse2001" $ \o ->
    InlineResponse2001
      <$> (o .:? "_meta")
      <*> (o .:? "end_users")

-- | ToJSON InlineResponse2001
instance A.ToJSON InlineResponse2001 where
  toJSON InlineResponse2001 {..} =
    A.object
      [ "_meta" .= inlineResponse2001Meta,
        "end_users" .= inlineResponse2001EndUsers
      ]

-- | Construct a value of type 'InlineResponse2001' (by applying it's required fields, if any)
mkInlineResponse2001 ::
  InlineResponse2001
mkInlineResponse2001 =
  InlineResponse2001
    { inlineResponse2001Meta = Nothing,
      inlineResponse2001EndUsers = Nothing
    }

-- ** InlineResponse2001Meta

-- | InlineResponse2001Meta
data InlineResponse2001Meta = InlineResponse2001Meta
  { -- | "limit"
    inlineResponse2001MetaLimit :: !(Maybe Int),
    -- | "next_url"
    inlineResponse2001MetaNextUrl :: !(Maybe Text),
    -- | "page"
    inlineResponse2001MetaPage :: !(Maybe Int),
    -- | "pages"
    inlineResponse2001MetaPages :: !(Maybe Int),
    -- | "prev_url"
    inlineResponse2001MetaPrevUrl :: !(Maybe Text),
    -- | "total"
    inlineResponse2001MetaTotal :: !(Maybe Int)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2001Meta
instance A.FromJSON InlineResponse2001Meta where
  parseJSON = A.withObject "InlineResponse2001Meta" $ \o ->
    InlineResponse2001Meta
      <$> (o .:? "limit")
      <*> (o .:? "next_url")
      <*> (o .:? "page")
      <*> (o .:? "pages")
      <*> (o .:? "prev_url")
      <*> (o .:? "total")

-- | ToJSON InlineResponse2001Meta
instance A.ToJSON InlineResponse2001Meta where
  toJSON InlineResponse2001Meta {..} =
    A.object
      [ "limit" .= inlineResponse2001MetaLimit,
        "next_url" .= inlineResponse2001MetaNextUrl,
        "page" .= inlineResponse2001MetaPage,
        "pages" .= inlineResponse2001MetaPages,
        "prev_url" .= inlineResponse2001MetaPrevUrl,
        "total" .= inlineResponse2001MetaTotal
      ]

-- | Construct a value of type 'InlineResponse2001Meta' (by applying it's required fields, if any)
mkInlineResponse2001Meta ::
  InlineResponse2001Meta
mkInlineResponse2001Meta =
  InlineResponse2001Meta
    { inlineResponse2001MetaLimit = Nothing,
      inlineResponse2001MetaNextUrl = Nothing,
      inlineResponse2001MetaPage = Nothing,
      inlineResponse2001MetaPages = Nothing,
      inlineResponse2001MetaPrevUrl = Nothing,
      inlineResponse2001MetaTotal = Nothing
    }

-- ** InlineResponse2002

-- | InlineResponse2002
data InlineResponse2002 = InlineResponse2002
  { -- | "accounts"
    inlineResponse2002Accounts :: !(Maybe [InlineResponse2002Accounts]),
    -- | "summary"
    inlineResponse2002Summary :: !(Maybe InlineResponse2002Summary)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002
instance A.FromJSON InlineResponse2002 where
  parseJSON = A.withObject "InlineResponse2002" $ \o ->
    InlineResponse2002
      <$> (o .:? "accounts")
      <*> (o .:? "summary")

-- | ToJSON InlineResponse2002
instance A.ToJSON InlineResponse2002 where
  toJSON InlineResponse2002 {..} =
    A.object
      [ "accounts" .= inlineResponse2002Accounts,
        "summary" .= inlineResponse2002Summary
      ]

-- | Construct a value of type 'InlineResponse2002' (by applying it's required fields, if any)
mkInlineResponse2002 ::
  InlineResponse2002
mkInlineResponse2002 =
  InlineResponse2002
    { inlineResponse2002Accounts = Nothing,
      inlineResponse2002Summary = Nothing
    }

-- ** InlineResponse2002Accounts

-- | InlineResponse2002Accounts
data InlineResponse2002Accounts = InlineResponse2002Accounts
  { -- | "account_id"
    inlineResponse2002AccountsAccountId :: !(Maybe Text),
    -- | "balance"
    inlineResponse2002AccountsBalance :: !(Maybe Double),
    -- | "last_transaction_timestamp"
    inlineResponse2002AccountsLastTransactionTimestamp :: !(Maybe DateTime)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002Accounts
instance A.FromJSON InlineResponse2002Accounts where
  parseJSON = A.withObject "InlineResponse2002Accounts" $ \o ->
    InlineResponse2002Accounts
      <$> (o .:? "account_id")
      <*> (o .:? "balance")
      <*> (o .:? "last_transaction_timestamp")

-- | ToJSON InlineResponse2002Accounts
instance A.ToJSON InlineResponse2002Accounts where
  toJSON InlineResponse2002Accounts {..} =
    A.object
      [ "account_id" .= inlineResponse2002AccountsAccountId,
        "balance" .= inlineResponse2002AccountsBalance,
        "last_transaction_timestamp" .= inlineResponse2002AccountsLastTransactionTimestamp
      ]

-- | Construct a value of type 'InlineResponse2002Accounts' (by applying it's required fields, if any)
mkInlineResponse2002Accounts ::
  InlineResponse2002Accounts
mkInlineResponse2002Accounts =
  InlineResponse2002Accounts
    { inlineResponse2002AccountsAccountId = Nothing,
      inlineResponse2002AccountsBalance = Nothing,
      inlineResponse2002AccountsLastTransactionTimestamp = Nothing
    }

-- ** InlineResponse2002Summary

-- | InlineResponse2002Summary
data InlineResponse2002Summary = InlineResponse2002Summary
  { -- | "balance"
    inlineResponse2002SummaryBalance :: !(Maybe Double),
    -- | "timestamp"
    inlineResponse2002SummaryTimestamp :: !(Maybe DateTime)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002Summary
instance A.FromJSON InlineResponse2002Summary where
  parseJSON = A.withObject "InlineResponse2002Summary" $ \o ->
    InlineResponse2002Summary
      <$> (o .:? "balance")
      <*> (o .:? "timestamp")

-- | ToJSON InlineResponse2002Summary
instance A.ToJSON InlineResponse2002Summary where
  toJSON InlineResponse2002Summary {..} =
    A.object
      [ "balance" .= inlineResponse2002SummaryBalance,
        "timestamp" .= inlineResponse2002SummaryTimestamp
      ]

-- | Construct a value of type 'InlineResponse2002Summary' (by applying it's required fields, if any)
mkInlineResponse2002Summary ::
  InlineResponse2002Summary
mkInlineResponse2002Summary =
  InlineResponse2002Summary
    { inlineResponse2002SummaryBalance = Nothing,
      inlineResponse2002SummaryTimestamp = Nothing
    }

-- ** InlineResponse2003

-- | InlineResponse2003
data InlineResponse2003 = InlineResponse2003
  { -- | "statistics"
    inlineResponse2003Statistics :: !(Maybe [InlineResponse2003Statistics])
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003
instance A.FromJSON InlineResponse2003 where
  parseJSON = A.withObject "InlineResponse2003" $ \o ->
    InlineResponse2003
      <$> (o .:? "statistics")

-- | ToJSON InlineResponse2003
instance A.ToJSON InlineResponse2003 where
  toJSON InlineResponse2003 {..} =
    A.object
      [ "statistics" .= inlineResponse2003Statistics
      ]

-- | Construct a value of type 'InlineResponse2003' (by applying it's required fields, if any)
mkInlineResponse2003 ::
  InlineResponse2003
mkInlineResponse2003 =
  InlineResponse2003
    { inlineResponse2003Statistics = Nothing
    }

-- ** InlineResponse2003Statistics

-- | InlineResponse2003Statistics
data InlineResponse2003Statistics = InlineResponse2003Statistics
  { -- | "dt"
    inlineResponse2003StatisticsDt :: !(Maybe Text),
    -- | "heron_id"
    inlineResponse2003StatisticsHeronId :: !(Maybe Text),
    -- | "label"
    inlineResponse2003StatisticsLabel :: !(Maybe Text),
    -- | "value"
    inlineResponse2003StatisticsValue :: !(Maybe Double)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003Statistics
instance A.FromJSON InlineResponse2003Statistics where
  parseJSON = A.withObject "InlineResponse2003Statistics" $ \o ->
    InlineResponse2003Statistics
      <$> (o .:? "dt")
      <*> (o .:? "heron_id")
      <*> (o .:? "label")
      <*> (o .:? "value")

-- | ToJSON InlineResponse2003Statistics
instance A.ToJSON InlineResponse2003Statistics where
  toJSON InlineResponse2003Statistics {..} =
    A.object
      [ "dt" .= inlineResponse2003StatisticsDt,
        "heron_id" .= inlineResponse2003StatisticsHeronId,
        "label" .= inlineResponse2003StatisticsLabel,
        "value" .= inlineResponse2003StatisticsValue
      ]

-- | Construct a value of type 'InlineResponse2003Statistics' (by applying it's required fields, if any)
mkInlineResponse2003Statistics ::
  InlineResponse2003Statistics
mkInlineResponse2003Statistics =
  InlineResponse2003Statistics
    { inlineResponse2003StatisticsDt = Nothing,
      inlineResponse2003StatisticsHeronId = Nothing,
      inlineResponse2003StatisticsLabel = Nothing,
      inlineResponse2003StatisticsValue = Nothing
    }

-- ** InlineResponse2004

-- | InlineResponse2004
data InlineResponse2004 = InlineResponse2004
  { -- | "hello"
    inlineResponse2004Hello :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2004
instance A.FromJSON InlineResponse2004 where
  parseJSON = A.withObject "InlineResponse2004" $ \o ->
    InlineResponse2004
      <$> (o .:? "hello")

-- | ToJSON InlineResponse2004
instance A.ToJSON InlineResponse2004 where
  toJSON InlineResponse2004 {..} =
    A.object
      [ "hello" .= inlineResponse2004Hello
      ]

-- | Construct a value of type 'InlineResponse2004' (by applying it's required fields, if any)
mkInlineResponse2004 ::
  InlineResponse2004
mkInlineResponse2004 =
  InlineResponse2004
    { inlineResponse2004Hello = Nothing
    }

-- ** InlineResponse2005

-- | InlineResponse2005
data InlineResponse2005 = InlineResponse2005
  { -- | "description_clean"
    inlineResponse2005DescriptionClean :: !(Maybe Text),
    -- | "merchant"
    inlineResponse2005Merchant :: !(Maybe MerchantExtract),
    -- | "payment_processor"
    inlineResponse2005PaymentProcessor :: !(Maybe PaymentProcessor)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2005
instance A.FromJSON InlineResponse2005 where
  parseJSON = A.withObject "InlineResponse2005" $ \o ->
    InlineResponse2005
      <$> (o .:? "description_clean")
      <*> (o .:? "merchant")
      <*> (o .:? "payment_processor")

-- | ToJSON InlineResponse2005
instance A.ToJSON InlineResponse2005 where
  toJSON InlineResponse2005 {..} =
    A.object
      [ "description_clean" .= inlineResponse2005DescriptionClean,
        "merchant" .= inlineResponse2005Merchant,
        "payment_processor" .= inlineResponse2005PaymentProcessor
      ]

-- | Construct a value of type 'InlineResponse2005' (by applying it's required fields, if any)
mkInlineResponse2005 ::
  InlineResponse2005
mkInlineResponse2005 =
  InlineResponse2005
    { inlineResponse2005DescriptionClean = Nothing,
      inlineResponse2005Merchant = Nothing,
      inlineResponse2005PaymentProcessor = Nothing
    }

-- ** InlineResponse2006

-- | InlineResponse2006
data InlineResponse2006 = InlineResponse2006
  { -- | "merchants"
    inlineResponse2006Merchants :: !(Maybe [Merchant])
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2006
instance A.FromJSON InlineResponse2006 where
  parseJSON = A.withObject "InlineResponse2006" $ \o ->
    InlineResponse2006
      <$> (o .:? "merchants")

-- | ToJSON InlineResponse2006
instance A.ToJSON InlineResponse2006 where
  toJSON InlineResponse2006 {..} =
    A.object
      [ "merchants" .= inlineResponse2006Merchants
      ]

-- | Construct a value of type 'InlineResponse2006' (by applying it's required fields, if any)
mkInlineResponse2006 ::
  InlineResponse2006
mkInlineResponse2006 =
  InlineResponse2006
    { inlineResponse2006Merchants = Nothing
    }

-- ** InlineResponse2007

-- | InlineResponse2007
data InlineResponse2007 = InlineResponse2007
  { -- | "merchant"
    inlineResponse2007Merchant :: !(Maybe Merchant)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2007
instance A.FromJSON InlineResponse2007 where
  parseJSON = A.withObject "InlineResponse2007" $ \o ->
    InlineResponse2007
      <$> (o .:? "merchant")

-- | ToJSON InlineResponse2007
instance A.ToJSON InlineResponse2007 where
  toJSON InlineResponse2007 {..} =
    A.object
      [ "merchant" .= inlineResponse2007Merchant
      ]

-- | Construct a value of type 'InlineResponse2007' (by applying it's required fields, if any)
mkInlineResponse2007 ::
  InlineResponse2007
mkInlineResponse2007 =
  InlineResponse2007
    { inlineResponse2007Merchant = Nothing
    }

-- ** InlineResponse2008

-- | InlineResponse2008
data InlineResponse2008 = InlineResponse2008
  { -- | "_meta"
    inlineResponse2008Meta :: !(Maybe InlineResponse2008Meta),
    -- | "_summary"
    inlineResponse2008Summary :: !(Maybe InlineResponse2008Summary),
    -- | "transactions"
    inlineResponse2008Transactions :: !(Maybe [TransactionGetOutput])
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2008
instance A.FromJSON InlineResponse2008 where
  parseJSON = A.withObject "InlineResponse2008" $ \o ->
    InlineResponse2008
      <$> (o .:? "_meta")
      <*> (o .:? "_summary")
      <*> (o .:? "transactions")

-- | ToJSON InlineResponse2008
instance A.ToJSON InlineResponse2008 where
  toJSON InlineResponse2008 {..} =
    A.object
      [ "_meta" .= inlineResponse2008Meta,
        "_summary" .= inlineResponse2008Summary,
        "transactions" .= inlineResponse2008Transactions
      ]

-- | Construct a value of type 'InlineResponse2008' (by applying it's required fields, if any)
mkInlineResponse2008 ::
  InlineResponse2008
mkInlineResponse2008 =
  InlineResponse2008
    { inlineResponse2008Meta = Nothing,
      inlineResponse2008Summary = Nothing,
      inlineResponse2008Transactions = Nothing
    }

-- ** InlineResponse2008Meta

-- | InlineResponse2008Meta
data InlineResponse2008Meta = InlineResponse2008Meta
  { -- | "next_url"
    inlineResponse2008MetaNextUrl :: !(Maybe Text),
    -- | "page"
    inlineResponse2008MetaPage :: !(Maybe Int),
    -- | "pages"
    inlineResponse2008MetaPages :: !(Maybe Int),
    -- | "per_page"
    inlineResponse2008MetaPerPage :: !(Maybe Int),
    -- | "prev_url"
    inlineResponse2008MetaPrevUrl :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2008Meta
instance A.FromJSON InlineResponse2008Meta where
  parseJSON = A.withObject "InlineResponse2008Meta" $ \o ->
    InlineResponse2008Meta
      <$> (o .:? "next_url")
      <*> (o .:? "page")
      <*> (o .:? "pages")
      <*> (o .:? "per_page")
      <*> (o .:? "prev_url")

-- | ToJSON InlineResponse2008Meta
instance A.ToJSON InlineResponse2008Meta where
  toJSON InlineResponse2008Meta {..} =
    A.object
      [ "next_url" .= inlineResponse2008MetaNextUrl,
        "page" .= inlineResponse2008MetaPage,
        "pages" .= inlineResponse2008MetaPages,
        "per_page" .= inlineResponse2008MetaPerPage,
        "prev_url" .= inlineResponse2008MetaPrevUrl
      ]

-- | Construct a value of type 'InlineResponse2008Meta' (by applying it's required fields, if any)
mkInlineResponse2008Meta ::
  InlineResponse2008Meta
mkInlineResponse2008Meta =
  InlineResponse2008Meta
    { inlineResponse2008MetaNextUrl = Nothing,
      inlineResponse2008MetaPage = Nothing,
      inlineResponse2008MetaPages = Nothing,
      inlineResponse2008MetaPerPage = Nothing,
      inlineResponse2008MetaPrevUrl = Nothing
    }

-- ** InlineResponse2008Summary

-- | InlineResponse2008Summary
data InlineResponse2008Summary = InlineResponse2008Summary
  { -- | "returned_transactions"
    inlineResponse2008SummaryReturnedTransactions :: !(Maybe Int),
    -- | "transactions"
    inlineResponse2008SummaryTransactions :: !(Maybe Int)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2008Summary
instance A.FromJSON InlineResponse2008Summary where
  parseJSON = A.withObject "InlineResponse2008Summary" $ \o ->
    InlineResponse2008Summary
      <$> (o .:? "returned_transactions")
      <*> (o .:? "transactions")

-- | ToJSON InlineResponse2008Summary
instance A.ToJSON InlineResponse2008Summary where
  toJSON InlineResponse2008Summary {..} =
    A.object
      [ "returned_transactions" .= inlineResponse2008SummaryReturnedTransactions,
        "transactions" .= inlineResponse2008SummaryTransactions
      ]

-- | Construct a value of type 'InlineResponse2008Summary' (by applying it's required fields, if any)
mkInlineResponse2008Summary ::
  InlineResponse2008Summary
mkInlineResponse2008Summary =
  InlineResponse2008Summary
    { inlineResponse2008SummaryReturnedTransactions = Nothing,
      inlineResponse2008SummaryTransactions = Nothing
    }

-- ** InlineResponse201

-- | InlineResponse201
data InlineResponse201 = InlineResponse201
  { -- | "_summary"
    inlineResponse201Summary :: !(Maybe InlineResponse201Summary),
    -- | "transactions"
    inlineResponse201Transactions :: !(Maybe [TransactionPostOutput])
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse201
instance A.FromJSON InlineResponse201 where
  parseJSON = A.withObject "InlineResponse201" $ \o ->
    InlineResponse201
      <$> (o .:? "_summary")
      <*> (o .:? "transactions")

-- | ToJSON InlineResponse201
instance A.ToJSON InlineResponse201 where
  toJSON InlineResponse201 {..} =
    A.object
      [ "_summary" .= inlineResponse201Summary,
        "transactions" .= inlineResponse201Transactions
      ]

-- | Construct a value of type 'InlineResponse201' (by applying it's required fields, if any)
mkInlineResponse201 ::
  InlineResponse201
mkInlineResponse201 =
  InlineResponse201
    { inlineResponse201Summary = Nothing,
      inlineResponse201Transactions = Nothing
    }

-- ** InlineResponse201Summary

-- | InlineResponse201Summary
data InlineResponse201Summary = InlineResponse201Summary
  { -- | "request_id" - Unique UUID per request
    inlineResponse201SummaryRequestId :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse201Summary
instance A.FromJSON InlineResponse201Summary where
  parseJSON = A.withObject "InlineResponse201Summary" $ \o ->
    InlineResponse201Summary
      <$> (o .:? "request_id")

-- | ToJSON InlineResponse201Summary
instance A.ToJSON InlineResponse201Summary where
  toJSON InlineResponse201Summary {..} =
    A.object
      [ "request_id" .= inlineResponse201SummaryRequestId
      ]

-- | Construct a value of type 'InlineResponse201Summary' (by applying it's required fields, if any)
mkInlineResponse201Summary ::
  InlineResponse201Summary
mkInlineResponse201Summary =
  InlineResponse201Summary
    { inlineResponse201SummaryRequestId = Nothing
    }

-- ** InlineResponse202

-- | InlineResponse202
data InlineResponse202 = InlineResponse202
  { -- | "message"
    inlineResponse202Message :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse202
instance A.FromJSON InlineResponse202 where
  parseJSON = A.withObject "InlineResponse202" $ \o ->
    InlineResponse202
      <$> (o .:? "message")

-- | ToJSON InlineResponse202
instance A.ToJSON InlineResponse202 where
  toJSON InlineResponse202 {..} =
    A.object
      [ "message" .= inlineResponse202Message
      ]

-- | Construct a value of type 'InlineResponse202' (by applying it's required fields, if any)
mkInlineResponse202 ::
  InlineResponse202
mkInlineResponse202 =
  InlineResponse202
    { inlineResponse202Message = Nothing
    }

-- ** InlineResponse413

-- | InlineResponse413
data InlineResponse413 = InlineResponse413
  { -- | "code"
    inlineResponse413Code :: !(Maybe Int),
    -- | "description"
    inlineResponse413Description :: !(Maybe Text),
    -- | "name"
    inlineResponse413Name :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse413
instance A.FromJSON InlineResponse413 where
  parseJSON = A.withObject "InlineResponse413" $ \o ->
    InlineResponse413
      <$> (o .:? "code")
      <*> (o .:? "description")
      <*> (o .:? "name")

-- | ToJSON InlineResponse413
instance A.ToJSON InlineResponse413 where
  toJSON InlineResponse413 {..} =
    A.object
      [ "code" .= inlineResponse413Code,
        "description" .= inlineResponse413Description,
        "name" .= inlineResponse413Name
      ]

-- | Construct a value of type 'InlineResponse413' (by applying it's required fields, if any)
mkInlineResponse413 ::
  InlineResponse413
mkInlineResponse413 =
  InlineResponse413
    { inlineResponse413Code = Nothing,
      inlineResponse413Description = Nothing,
      inlineResponse413Name = Nothing
    }

-- ** Merchant

-- | Merchant
data Merchant = Merchant
  { -- | /ReadOnly/ "categories"
    merchantCategories :: !(Maybe [MerchantCategory]),
    -- | /ReadOnly/ "heron_id"
    merchantHeronId :: !(Maybe Text),
    -- | "icon_url"
    merchantIconUrl :: !(Maybe Text),
    -- | "logo_url"
    merchantLogoUrl :: !(Maybe Text),
    -- | /Required/ "name"
    merchantName :: !(Text),
    -- | /Required/ "url"
    merchantUrl :: !(Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Merchant
instance A.FromJSON Merchant where
  parseJSON = A.withObject "Merchant" $ \o ->
    Merchant
      <$> (o .:? "categories")
      <*> (o .:? "heron_id")
      <*> (o .:? "icon_url")
      <*> (o .:? "logo_url")
      -- Workaround nullable merchant objects in response
      <*> (o .:? "name" .!= "UNDEFINED")
      <*> (o .:? "url" .!= "UNDEFINED")

-- | ToJSON Merchant
instance A.ToJSON Merchant where
  toJSON Merchant {..} =
    A.object
      [ "categories" .= merchantCategories,
        "heron_id" .= merchantHeronId,
        "icon_url" .= merchantIconUrl,
        "logo_url" .= merchantLogoUrl,
        "name" .= merchantName,
        "url" .= merchantUrl
      ]

-- | Construct a value of type 'Merchant' (by applying it's required fields, if any)
mkMerchant ::
  -- | 'merchantName'
  Text ->
  -- | 'merchantUrl'
  Text ->
  Merchant
mkMerchant merchantName merchantUrl =
  Merchant
    { merchantCategories = Nothing,
      merchantHeronId = Nothing,
      merchantIconUrl = Nothing,
      merchantLogoUrl = Nothing,
      merchantName,
      merchantUrl
    }

-- ** MerchantCategory

-- | MerchantCategory
data MerchantCategory = MerchantCategory
  { -- | /Required/ /ReadOnly/ "code"
    merchantCategoryCode :: !(Text),
    -- | /ReadOnly/ "description"
    merchantCategoryDescription :: !(Maybe Text),
    -- | /ReadOnly/ "slug"
    merchantCategorySlug :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MerchantCategory
instance A.FromJSON MerchantCategory where
  parseJSON = A.withObject "MerchantCategory" $ \o ->
    MerchantCategory
      <$> (o .: "code")
      <*> (o .:? "description")
      <*> (o .:? "slug")

-- | ToJSON MerchantCategory
instance A.ToJSON MerchantCategory where
  toJSON MerchantCategory {..} =
    A.object
      [ "code" .= merchantCategoryCode,
        "description" .= merchantCategoryDescription,
        "slug" .= merchantCategorySlug
      ]

-- | Construct a value of type 'MerchantCategory' (by applying it's required fields, if any)
mkMerchantCategory ::
  -- | 'merchantCategoryCode'
  Text ->
  MerchantCategory
mkMerchantCategory merchantCategoryCode =
  MerchantCategory
    { merchantCategoryCode,
      merchantCategoryDescription = Nothing,
      merchantCategorySlug = Nothing
    }

-- ** MerchantExtract

-- | MerchantExtract
data MerchantExtract = MerchantExtract
  { -- | /ReadOnly/ "categories"
    merchantExtractCategories :: !(Maybe [MerchantCategory]),
    -- | "confidence"
    merchantExtractConfidence :: !(Maybe Double),
    -- | /ReadOnly/ "heron_id"
    merchantExtractHeronId :: !(Maybe Text),
    -- | /ReadOnly/ "icon_url"
    merchantExtractIconUrl :: !(Maybe Text),
    -- | /ReadOnly/ "logo_url"
    merchantExtractLogoUrl :: !(Maybe Text),
    -- | /ReadOnly/ "name"
    merchantExtractName :: !(Maybe Text),
    -- | /ReadOnly/ "url"
    merchantExtractUrl :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MerchantExtract
instance A.FromJSON MerchantExtract where
  parseJSON = A.withObject "MerchantExtract" $ \o ->
    MerchantExtract
      <$> (o .:? "categories")
      <*> (o .:? "confidence")
      <*> (o .:? "heron_id")
      <*> (o .:? "icon_url")
      <*> (o .:? "logo_url")
      <*> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON MerchantExtract
instance A.ToJSON MerchantExtract where
  toJSON MerchantExtract {..} =
    A.object
      [ "categories" .= merchantExtractCategories,
        "confidence" .= merchantExtractConfidence,
        "heron_id" .= merchantExtractHeronId,
        "icon_url" .= merchantExtractIconUrl,
        "logo_url" .= merchantExtractLogoUrl,
        "name" .= merchantExtractName,
        "url" .= merchantExtractUrl
      ]

-- | Construct a value of type 'MerchantExtract' (by applying it's required fields, if any)
mkMerchantExtract ::
  MerchantExtract
mkMerchantExtract =
  MerchantExtract
    { merchantExtractCategories = Nothing,
      merchantExtractConfidence = Nothing,
      merchantExtractHeronId = Nothing,
      merchantExtractIconUrl = Nothing,
      merchantExtractLogoUrl = Nothing,
      merchantExtractName = Nothing,
      merchantExtractUrl = Nothing
    }

-- ** MerchantFeedback

-- | MerchantFeedback
data MerchantFeedback = MerchantFeedback
  { -- | "heron_id"
    merchantFeedbackHeronId :: !(Maybe Text),
    -- | "is_correct"
    merchantFeedbackIsCorrect :: !(Maybe Bool),
    -- | "name"
    merchantFeedbackName :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MerchantFeedback
instance A.FromJSON MerchantFeedback where
  parseJSON = A.withObject "MerchantFeedback" $ \o ->
    MerchantFeedback
      <$> (o .:? "heron_id")
      <*> (o .:? "is_correct")
      <*> (o .:? "name")

-- | ToJSON MerchantFeedback
instance A.ToJSON MerchantFeedback where
  toJSON MerchantFeedback {..} =
    A.object
      [ "heron_id" .= merchantFeedbackHeronId,
        "is_correct" .= merchantFeedbackIsCorrect,
        "name" .= merchantFeedbackName
      ]

-- | Construct a value of type 'MerchantFeedback' (by applying it's required fields, if any)
mkMerchantFeedback ::
  MerchantFeedback
mkMerchantFeedback =
  MerchantFeedback
    { merchantFeedbackHeronId = Nothing,
      merchantFeedbackIsCorrect = Nothing,
      merchantFeedbackName = Nothing
    }

-- ** PaymentProcessor

-- | PaymentProcessor
data PaymentProcessor = PaymentProcessor
  { -- | /ReadOnly/ "heron_id"
    paymentProcessorHeronId :: !(Maybe Text),
    -- | /Required/ "name"
    paymentProcessorName :: !(Text),
    -- | /Required/ "url"
    paymentProcessorUrl :: !(Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentProcessor
instance A.FromJSON PaymentProcessor where
  parseJSON = A.withObject "PaymentProcessor" $ \o ->
    PaymentProcessor
      <$> (o .:? "heron_id")
      <*> (o .:? "name" .!= "UNDEFINED")
      <*> (o .:? "url" .!= "UNDEFINED")

-- | ToJSON PaymentProcessor
instance A.ToJSON PaymentProcessor where
  toJSON PaymentProcessor {..} =
    A.object
      [ "heron_id" .= paymentProcessorHeronId,
        "name" .= paymentProcessorName,
        "url" .= paymentProcessorUrl
      ]

-- | Construct a value of type 'PaymentProcessor' (by applying it's required fields, if any)
mkPaymentProcessor ::
  -- | 'paymentProcessorName'
  Text ->
  -- | 'paymentProcessorUrl'
  Text ->
  PaymentProcessor
mkPaymentProcessor paymentProcessorName paymentProcessorUrl =
  PaymentProcessor
    { paymentProcessorHeronId = Nothing,
      paymentProcessorName,
      paymentProcessorUrl
    }

-- ** TransactionAnnotation

-- | TransactionAnnotation
data TransactionAnnotation = TransactionAnnotation
  { -- | "annotator" - Annotator type
    transactionAnnotationAnnotator :: !(Maybe Text),
    -- | "confidence" - The confidence associated with the category annotation
    transactionAnnotationConfidence :: !(Maybe Double),
    -- | "heron_id" - Unique ID of category; generated by Heron Data
    transactionAnnotationHeronId :: !(Maybe Text),
    -- | "label" - Label of category
    transactionAnnotationLabel :: !(Maybe Text),
    -- | "model_version" - The model version that produced the categorisation
    transactionAnnotationModelVersion :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionAnnotation
instance A.FromJSON TransactionAnnotation where
  parseJSON = A.withObject "TransactionAnnotation" $ \o ->
    TransactionAnnotation
      <$> (o .:? "annotator")
      <*> (o .:? "confidence")
      <*> (o .:? "heron_id")
      <*> (o .:? "label")
      <*> (o .:? "model_version")

-- | ToJSON TransactionAnnotation
instance A.ToJSON TransactionAnnotation where
  toJSON TransactionAnnotation {..} =
    A.object
      [ "annotator" .= transactionAnnotationAnnotator,
        "confidence" .= transactionAnnotationConfidence,
        "heron_id" .= transactionAnnotationHeronId,
        "label" .= transactionAnnotationLabel,
        "model_version" .= transactionAnnotationModelVersion
      ]

-- | Construct a value of type 'TransactionAnnotation' (by applying it's required fields, if any)
mkTransactionAnnotation ::
  TransactionAnnotation
mkTransactionAnnotation =
  TransactionAnnotation
    { transactionAnnotationAnnotator = Nothing,
      transactionAnnotationConfidence = Nothing,
      transactionAnnotationHeronId = Nothing,
      transactionAnnotationLabel = Nothing,
      transactionAnnotationModelVersion = Nothing
    }

-- ** TransactionFeedbackParams

-- | TransactionFeedbackParams
data TransactionFeedbackParams = TransactionFeedbackParams
  { -- | "trigger_webhook" - If true, enables the triggering of transaction_updated webhook. Set to false to supress trigger. Default true
    transactionFeedbackParamsTriggerWebhook :: !(Maybe Bool)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionFeedbackParams
instance A.FromJSON TransactionFeedbackParams where
  parseJSON = A.withObject "TransactionFeedbackParams" $ \o ->
    TransactionFeedbackParams
      <$> (o .:? "trigger_webhook")

-- | ToJSON TransactionFeedbackParams
instance A.ToJSON TransactionFeedbackParams where
  toJSON TransactionFeedbackParams {..} =
    A.object
      [ "trigger_webhook" .= transactionFeedbackParamsTriggerWebhook
      ]

-- | Construct a value of type 'TransactionFeedbackParams' (by applying it's required fields, if any)
mkTransactionFeedbackParams ::
  TransactionFeedbackParams
mkTransactionFeedbackParams =
  TransactionFeedbackParams
    { transactionFeedbackParamsTriggerWebhook = Nothing
    }

-- ** TransactionFeedbackSchema

-- | TransactionFeedbackSchema
data TransactionFeedbackSchema = TransactionFeedbackSchema
  { -- | "category"
    transactionFeedbackSchemaCategory :: !(Maybe CategoryFeedback),
    -- | "merchant"
    transactionFeedbackSchemaMerchant :: !(Maybe MerchantFeedback)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionFeedbackSchema
instance A.FromJSON TransactionFeedbackSchema where
  parseJSON = A.withObject "TransactionFeedbackSchema" $ \o ->
    TransactionFeedbackSchema
      <$> (o .:? "category")
      <*> (o .:? "merchant")

-- | ToJSON TransactionFeedbackSchema
instance A.ToJSON TransactionFeedbackSchema where
  toJSON TransactionFeedbackSchema {..} =
    A.object
      [ "category" .= transactionFeedbackSchemaCategory,
        "merchant" .= transactionFeedbackSchemaMerchant
      ]

-- | Construct a value of type 'TransactionFeedbackSchema' (by applying it's required fields, if any)
mkTransactionFeedbackSchema ::
  TransactionFeedbackSchema
mkTransactionFeedbackSchema =
  TransactionFeedbackSchema
    { transactionFeedbackSchemaCategory = Nothing,
      transactionFeedbackSchemaMerchant = Nothing
    }

-- ** TransactionGetOutput

-- | TransactionGetOutput
data TransactionGetOutput = TransactionGetOutput
  { -- | "account_id" - Your unique ID for account associated with transaction
    transactionGetOutputAccountId :: !(Maybe Text),
    -- | /Required/ "amount" - Amount of transaction
    transactionGetOutputAmount :: !(Double),
    -- | "balance" - The running balance of the account after transaction ocurred
    transactionGetOutputBalance :: !(Maybe Double),
    -- | "categories" - The category associated with the transaction
    transactionGetOutputCategories :: !(Maybe [TransactionAnnotation]),
    -- | "created" - When transaction was created in Heron system
    transactionGetOutputCreated :: !(Maybe DateTime),
    -- | "currency" - ISO 4217 currency code
    transactionGetOutputCurrency :: !(Maybe Text),
    -- | /Required/ "description" - The text description for the transaction
    transactionGetOutputDescription :: !(Text),
    -- | "description_clean" - The cleaned description of the transaction
    transactionGetOutputDescriptionClean :: !(Maybe Text),
    -- | "duplicate_of_id" - Indicates that the transaction is a duplicate and gives the heron_id of the original
    transactionGetOutputDuplicateOfId :: !(Maybe Text),
    -- | "end_user_id" - Your unique ID for end user associated with transaction
    transactionGetOutputEndUserId :: !(Maybe Text),
    -- | "has_matching_transaction" - Whether the transaction is a transfer; requires end_user_id and timestamp to be present
    transactionGetOutputHasMatchingTransaction :: !(Maybe Bool),
    -- | "heron_id" - Unique ID of transaction; generated by Heron Data
    transactionGetOutputHeronId :: !(Maybe Text),
    -- | /ReadOnly/ "is_potential_duplicate" - Indicates whether the transaction has another transaction similar to it
    transactionGetOutputIsPotentialDuplicate :: !(Maybe Bool),
    -- | "is_recurring" - Whether the transaction is recurring or not; requires end_user_id and timestamp to be present
    transactionGetOutputIsRecurring :: !(Maybe Bool),
    -- | "last_updated" - When transaction was last updated in Heron system; could be from recategorisation or attribute updates
    transactionGetOutputLastUpdated :: !(Maybe DateTime),
    -- | "mcc_code" - Merchant category code associated with transaction that you may have received from other sources
    transactionGetOutputMccCode :: !(Maybe Text),
    -- | "merchant" - The merchant associated with the transaction
    transactionGetOutputMerchant :: !(Maybe Merchant),
    -- | "payment_processor" - The payment processor associated with the transaction
    transactionGetOutputPaymentProcessor :: !(Maybe PaymentProcessor),
    -- | "reference_id" - Your unique ID for transaction
    transactionGetOutputReferenceId :: !(Maybe Text),
    -- | "request_id" - ID associated with request, e.g., all transactions in same POST request will have same request_id
    transactionGetOutputRequestId :: !(Maybe Text),
    -- | "timestamp" - The ISO 8601 timezone aware timestamp of the transaction; takes precedence over &#39;date&#39;
    transactionGetOutputTimestamp :: !(Maybe DateTime),
    -- | "transaction_code" - Code associated with transaction to indicate the type of transaction
    transactionGetOutputTransactionCode :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionGetOutput
instance A.FromJSON TransactionGetOutput where
  parseJSON = A.withObject "TransactionGetOutput" $ \o -> do
    -- Workaround for "non" nullable fields in responses
    let merchantFieldParser =
          o .:? "merchant" <&> \case
            Just Merchant {merchantName = "UNDEFINED"} -> Nothing
            Just Merchant {merchantUrl = "UNDEFINED"} -> Nothing
            success -> success
        paymentProcessorParser =
          (o .:? "payment_processor") <&> \case
            Just PaymentProcessor {paymentProcessorName = "UNDEFINED"} -> Nothing
            Just PaymentProcessor {paymentProcessorUrl = "UNDEFINED"} -> Nothing
            success -> success

    TransactionGetOutput
      <$> (o .:? "account_id")
      <*> (o .: "amount")
      <*> (o .:? "balance")
      <*> (o .:? "categories")
      <*> (o .:? "created")
      <*> (o .:? "currency")
      <*> (o .: "description")
      <*> (o .:? "description_clean")
      <*> (o .:? "duplicate_of_id")
      <*> (o .:? "end_user_id")
      <*> (o .:? "has_matching_transaction")
      <*> (o .:? "heron_id")
      <*> (o .:? "is_potential_duplicate")
      <*> (o .:? "is_recurring")
      <*> (o .:? "last_updated")
      <*> (o .:? "mcc_code")
      <*> merchantFieldParser
      <*> paymentProcessorParser
      <*> (o .:? "reference_id")
      <*> (o .:? "request_id")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction_code")

-- | ToJSON TransactionGetOutput
instance A.ToJSON TransactionGetOutput where
  toJSON TransactionGetOutput {..} =
    A.object
      [ "account_id" .= transactionGetOutputAccountId,
        "amount" .= transactionGetOutputAmount,
        "balance" .= transactionGetOutputBalance,
        "categories" .= transactionGetOutputCategories,
        "created" .= transactionGetOutputCreated,
        "currency" .= transactionGetOutputCurrency,
        "description" .= transactionGetOutputDescription,
        "description_clean" .= transactionGetOutputDescriptionClean,
        "duplicate_of_id" .= transactionGetOutputDuplicateOfId,
        "end_user_id" .= transactionGetOutputEndUserId,
        "has_matching_transaction" .= transactionGetOutputHasMatchingTransaction,
        "heron_id" .= transactionGetOutputHeronId,
        "is_potential_duplicate" .= transactionGetOutputIsPotentialDuplicate,
        "is_recurring" .= transactionGetOutputIsRecurring,
        "last_updated" .= transactionGetOutputLastUpdated,
        "mcc_code" .= transactionGetOutputMccCode,
        "merchant" .= transactionGetOutputMerchant,
        "payment_processor" .= transactionGetOutputPaymentProcessor,
        "reference_id" .= transactionGetOutputReferenceId,
        "request_id" .= transactionGetOutputRequestId,
        "timestamp" .= transactionGetOutputTimestamp,
        "transaction_code" .= transactionGetOutputTransactionCode
      ]

-- | Construct a value of type 'TransactionGetOutput' (by applying it's required fields, if any)
mkTransactionGetOutput ::
  -- | 'transactionGetOutputAmount': Amount of transaction
  Double ->
  -- | 'transactionGetOutputDescription': The text description for the transaction
  Text ->
  TransactionGetOutput
mkTransactionGetOutput transactionGetOutputAmount transactionGetOutputDescription =
  TransactionGetOutput
    { transactionGetOutputAccountId = Nothing,
      transactionGetOutputAmount,
      transactionGetOutputBalance = Nothing,
      transactionGetOutputCategories = Nothing,
      transactionGetOutputCreated = Nothing,
      transactionGetOutputCurrency = Nothing,
      transactionGetOutputDescription,
      transactionGetOutputDescriptionClean = Nothing,
      transactionGetOutputDuplicateOfId = Nothing,
      transactionGetOutputEndUserId = Nothing,
      transactionGetOutputHasMatchingTransaction = Nothing,
      transactionGetOutputHeronId = Nothing,
      transactionGetOutputIsPotentialDuplicate = Nothing,
      transactionGetOutputIsRecurring = Nothing,
      transactionGetOutputLastUpdated = Nothing,
      transactionGetOutputMccCode = Nothing,
      transactionGetOutputMerchant = Nothing,
      transactionGetOutputPaymentProcessor = Nothing,
      transactionGetOutputReferenceId = Nothing,
      transactionGetOutputRequestId = Nothing,
      transactionGetOutputTimestamp = Nothing,
      transactionGetOutputTransactionCode = Nothing
    }

-- ** TransactionInput

-- | TransactionInput
data TransactionInput = TransactionInput
  { -- | "account_id" - Your unique ID for account associated with transaction
    transactionInputAccountId :: !(Maybe Text),
    -- | /Required/ "amount" - Amount of transaction
    transactionInputAmount :: !(Double),
    -- | "balance" - The running balance of the account after transaction ocurred
    transactionInputBalance :: !(Maybe Double),
    -- | "categories_default" - Category of transaction that you may have received from other sources
    transactionInputCategoriesDefault :: !(Maybe [Text]),
    -- | "currency" - ISO 4217 currency code
    transactionInputCurrency :: !(Maybe Text),
    -- | "date" - The date of the transaction; &#39;timestamp&#39; field takes priority over &#39;date&#39;
    transactionInputDate :: !(Maybe Date),
    -- | /Required/ "description" - The text description for the transaction
    transactionInputDescription :: !(Text),
    -- | "end_user_id" - Your unique ID for end user associated with transaction
    transactionInputEndUserId :: !(Maybe Text),
    -- | "mcc_code" - Merchant category code associated with transaction that you may have received from other sources
    transactionInputMccCode :: !(Maybe Text),
    -- | "merchant_name" - Merchant name associated with transaction that you may have received from other sources
    transactionInputMerchantName :: !(Maybe Text),
    -- | "reference_id" - Your unique ID for transaction
    transactionInputReferenceId :: !(Maybe Text),
    -- | "timestamp" - The ISO 8601 timezone aware timestamp of the transaction; takes precedence over &#39;date&#39;
    transactionInputTimestamp :: !(Maybe DateTime),
    -- | "transaction_code" - Code associated with transaction to indicate the type of transaction
    transactionInputTransactionCode :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionInput
instance A.FromJSON TransactionInput where
  parseJSON = A.withObject "TransactionInput" $ \o ->
    TransactionInput
      <$> (o .:? "account_id")
      <*> (o .: "amount")
      <*> (o .:? "balance")
      <*> (o .:? "categories_default")
      <*> (o .:? "currency")
      <*> (o .:? "date")
      <*> (o .: "description")
      <*> (o .:? "end_user_id")
      <*> (o .:? "mcc_code")
      <*> (o .:? "merchant_name")
      <*> (o .:? "reference_id")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction_code")

-- | ToJSON TransactionInput
instance A.ToJSON TransactionInput where
  toJSON TransactionInput {..} =
    A.object
      [ "account_id" .= transactionInputAccountId,
        "amount" .= transactionInputAmount,
        "balance" .= transactionInputBalance,
        "categories_default" .= transactionInputCategoriesDefault,
        "currency" .= transactionInputCurrency,
        "date" .= transactionInputDate,
        "description" .= transactionInputDescription,
        "end_user_id" .= transactionInputEndUserId,
        "mcc_code" .= transactionInputMccCode,
        "merchant_name" .= transactionInputMerchantName,
        "reference_id" .= transactionInputReferenceId,
        "timestamp" .= transactionInputTimestamp,
        "transaction_code" .= transactionInputTransactionCode
      ]

-- | Construct a value of type 'TransactionInput' (by applying it's required fields, if any)
mkTransactionInput ::
  -- | 'transactionInputAmount': Amount of transaction
  Double ->
  -- | 'transactionInputDescription': The text description for the transaction
  Text ->
  TransactionInput
mkTransactionInput transactionInputAmount transactionInputDescription =
  TransactionInput
    { transactionInputAccountId = Nothing,
      transactionInputAmount,
      transactionInputBalance = Nothing,
      transactionInputCategoriesDefault = Nothing,
      transactionInputCurrency = Nothing,
      transactionInputDate = Nothing,
      transactionInputDescription,
      transactionInputEndUserId = Nothing,
      transactionInputMccCode = Nothing,
      transactionInputMerchantName = Nothing,
      transactionInputReferenceId = Nothing,
      transactionInputTimestamp = Nothing,
      transactionInputTransactionCode = Nothing
    }

-- ** TransactionPostOutput

-- | TransactionPostOutput
data TransactionPostOutput = TransactionPostOutput
  { -- | "account_id" - Your unique ID for account associated with transaction
    transactionPostOutputAccountId :: !(Maybe Text),
    -- | /Required/ "amount" - Amount of transaction
    transactionPostOutputAmount :: !(Double),
    -- | "balance" - The running balance of the account after transaction ocurred
    transactionPostOutputBalance :: !(Maybe Double),
    -- | "categories" - The category associated with the transaction
    transactionPostOutputCategories :: !(Maybe [TransactionAnnotation]),
    -- | "currency" - ISO 4217 currency code
    transactionPostOutputCurrency :: !(Maybe Text),
    -- | /Required/ "description" - The text description for the transaction
    transactionPostOutputDescription :: !(Text),
    -- | "description_clean" - The cleaned description of the transaction
    transactionPostOutputDescriptionClean :: !(Maybe Text),
    -- | "duplicate_of_id" - Indicates that the transaction is a duplicate and gives the heron_id of the original
    transactionPostOutputDuplicateOfId :: !(Maybe Text),
    -- | "end_user_id" - Your unique ID for end user associated with transaction
    transactionPostOutputEndUserId :: !(Maybe Text),
    -- | "has_matching_transaction" - Whether the transaction is a transfer; requires end_user_id and timestamp to be present
    transactionPostOutputHasMatchingTransaction :: !(Maybe Bool),
    -- | "heron_id" - Unique ID of transaction; generated by Heron Data
    transactionPostOutputHeronId :: !(Maybe Text),
    -- | /ReadOnly/ "is_potential_duplicate" - Indicates whether the transaction has another transaction similar to it
    transactionPostOutputIsPotentialDuplicate :: !(Maybe Bool),
    -- | "is_recurring" - Whether the transaction is recurring or not; requires end_user_id and timestamp to be present
    transactionPostOutputIsRecurring :: !(Maybe Bool),
    -- | "mcc_code" - Merchant category code associated with transaction that you may have received from other sources
    transactionPostOutputMccCode :: !(Maybe Text),
    -- | "merchant" - The merchant associated with the transaction
    transactionPostOutputMerchant :: !(Maybe Merchant),
    -- | "payment_processor" - The payment processor associated with the transaction
    transactionPostOutputPaymentProcessor :: !(Maybe PaymentProcessor),
    -- | "reference_id" - Your unique ID for transaction
    transactionPostOutputReferenceId :: !(Maybe Text),
    -- | "request_id" - ID associated with request, e.g., all transactions in same POST request will have same request_id
    transactionPostOutputRequestId :: !(Maybe Text),
    -- | "timestamp" - The ISO 8601 timezone aware timestamp of the transaction; takes precedence over &#39;date&#39;
    transactionPostOutputTimestamp :: !(Maybe DateTime),
    -- | "transaction_code" - Code associated with transaction to indicate the type of transaction
    transactionPostOutputTransactionCode :: !(Maybe Text)
  }
  deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransactionPostOutput
instance A.FromJSON TransactionPostOutput where
  parseJSON = A.withObject "TransactionPostOutput" $ \o -> do
    -- Workaround for "non" nullable fields in responses
    let merchantFieldParser =
          o .:? "merchant" <&> \case
            Just Merchant {merchantName = "UNDEFINED"} -> Nothing
            Just Merchant {merchantUrl = "UNDEFINED"} -> Nothing
            success -> success
        paymentProcessorParser =
          (o .:? "payment_processor") <&> \case
            Just PaymentProcessor {paymentProcessorName = "UNDEFINED"} -> Nothing
            Just PaymentProcessor {paymentProcessorUrl = "UNDEFINED"} -> Nothing
            success -> success

    TransactionPostOutput
      <$> (o .:? "account_id")
      <*> (o .: "amount")
      <*> (o .:? "balance")
      <*> (o .:? "categories")
      <*> (o .:? "currency")
      <*> (o .: "description")
      <*> (o .:? "description_clean")
      <*> (o .:? "duplicate_of_id")
      <*> (o .:? "end_user_id")
      <*> (o .:? "has_matching_transaction")
      <*> (o .:? "heron_id")
      <*> (o .:? "is_potential_duplicate")
      <*> (o .:? "is_recurring")
      <*> (o .:? "mcc_code")
      <*> merchantFieldParser
      <*> paymentProcessorParser
      <*> (o .:? "reference_id")
      <*> (o .:? "request_id")
      <*> (o .:? "timestamp")
      <*> (o .:? "transaction_code")

-- | ToJSON TransactionPostOutput
instance A.ToJSON TransactionPostOutput where
  toJSON TransactionPostOutput {..} =
    A.object
      [ "account_id" .= transactionPostOutputAccountId,
        "amount" .= transactionPostOutputAmount,
        "balance" .= transactionPostOutputBalance,
        "categories" .= transactionPostOutputCategories,
        "currency" .= transactionPostOutputCurrency,
        "description" .= transactionPostOutputDescription,
        "description_clean" .= transactionPostOutputDescriptionClean,
        "duplicate_of_id" .= transactionPostOutputDuplicateOfId,
        "end_user_id" .= transactionPostOutputEndUserId,
        "has_matching_transaction" .= transactionPostOutputHasMatchingTransaction,
        "heron_id" .= transactionPostOutputHeronId,
        "is_potential_duplicate" .= transactionPostOutputIsPotentialDuplicate,
        "is_recurring" .= transactionPostOutputIsRecurring,
        "mcc_code" .= transactionPostOutputMccCode,
        "merchant" .= transactionPostOutputMerchant,
        "payment_processor" .= transactionPostOutputPaymentProcessor,
        "reference_id" .= transactionPostOutputReferenceId,
        "request_id" .= transactionPostOutputRequestId,
        "timestamp" .= transactionPostOutputTimestamp,
        "transaction_code" .= transactionPostOutputTransactionCode
      ]

-- | Construct a value of type 'TransactionPostOutput' (by applying it's required fields, if any)
mkTransactionPostOutput ::
  -- | 'transactionPostOutputAmount': Amount of transaction
  Double ->
  -- | 'transactionPostOutputDescription': The text description for the transaction
  Text ->
  TransactionPostOutput
mkTransactionPostOutput transactionPostOutputAmount transactionPostOutputDescription =
  TransactionPostOutput
    { transactionPostOutputAccountId = Nothing,
      transactionPostOutputAmount,
      transactionPostOutputBalance = Nothing,
      transactionPostOutputCategories = Nothing,
      transactionPostOutputCurrency = Nothing,
      transactionPostOutputDescription,
      transactionPostOutputDescriptionClean = Nothing,
      transactionPostOutputDuplicateOfId = Nothing,
      transactionPostOutputEndUserId = Nothing,
      transactionPostOutputHasMatchingTransaction = Nothing,
      transactionPostOutputHeronId = Nothing,
      transactionPostOutputIsPotentialDuplicate = Nothing,
      transactionPostOutputIsRecurring = Nothing,
      transactionPostOutputMccCode = Nothing,
      transactionPostOutputMerchant = Nothing,
      transactionPostOutputPaymentProcessor = Nothing,
      transactionPostOutputReferenceId = Nothing,
      transactionPostOutputRequestId = Nothing,
      transactionPostOutputTimestamp = Nothing,
      transactionPostOutputTransactionCode = Nothing
    }

-- * Enums

-- ** E'DateGranularity

-- | Enum of 'Text' .
-- Aggregate results over time, i.e., aggregate by week or by month
data E'DateGranularity
  = -- | @"week"@
    E'DateGranularity'Week
  | -- | @"month"@
    E'DateGranularity'Month
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'DateGranularity where toJSON = A.toJSON . fromE'DateGranularity

instance A.FromJSON E'DateGranularity where parseJSON o = P.either P.fail (pure . P.id) . toE'DateGranularity =<< A.parseJSON o

instance WH.ToHttpApiData E'DateGranularity where toQueryParam = WH.toQueryParam . fromE'DateGranularity

instance WH.FromHttpApiData E'DateGranularity where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'DateGranularity

instance MimeRender MimeMultipartFormData E'DateGranularity where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'DateGranularity' enum
fromE'DateGranularity :: E'DateGranularity -> Text
fromE'DateGranularity = \case
  E'DateGranularity'Week -> "week"
  E'DateGranularity'Month -> "month"

-- | parse 'E'DateGranularity' enum
toE'DateGranularity :: Text -> P.Either String E'DateGranularity
toE'DateGranularity = \case
  "week" -> P.Right E'DateGranularity'Week
  "month" -> P.Right E'DateGranularity'Month
  s -> P.Left $ "toE'DateGranularity: enum parse failure: " P.++ P.show s

-- ** E'DateGranularity2

-- | Enum of 'Text' .
-- Aggregate results over time, e.g., by week or by quarter
data E'DateGranularity2
  = -- | @"day"@
    E'DateGranularity2'Day
  | -- | @"week"@
    E'DateGranularity2'Week
  | -- | @"month"@
    E'DateGranularity2'Month
  | -- | @"quarter"@
    E'DateGranularity2'Quarter
  | -- | @"year"@
    E'DateGranularity2'Year
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'DateGranularity2 where toJSON = A.toJSON . fromE'DateGranularity2

instance A.FromJSON E'DateGranularity2 where parseJSON o = P.either P.fail (pure . P.id) . toE'DateGranularity2 =<< A.parseJSON o

instance WH.ToHttpApiData E'DateGranularity2 where toQueryParam = WH.toQueryParam . fromE'DateGranularity2

instance WH.FromHttpApiData E'DateGranularity2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'DateGranularity2

instance MimeRender MimeMultipartFormData E'DateGranularity2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'DateGranularity2' enum
fromE'DateGranularity2 :: E'DateGranularity2 -> Text
fromE'DateGranularity2 = \case
  E'DateGranularity2'Day -> "day"
  E'DateGranularity2'Week -> "week"
  E'DateGranularity2'Month -> "month"
  E'DateGranularity2'Quarter -> "quarter"
  E'DateGranularity2'Year -> "year"

-- | parse 'E'DateGranularity2' enum
toE'DateGranularity2 :: Text -> P.Either String E'DateGranularity2
toE'DateGranularity2 = \case
  "day" -> P.Right E'DateGranularity2'Day
  "week" -> P.Right E'DateGranularity2'Week
  "month" -> P.Right E'DateGranularity2'Month
  "quarter" -> P.Right E'DateGranularity2'Quarter
  "year" -> P.Right E'DateGranularity2'Year
  s -> P.Left $ "toE'DateGranularity2: enum parse failure: " P.++ P.show s

-- ** E'GroupBy

-- | Enum of 'Text' .
-- Pivot results by merchant or by category
data E'GroupBy
  = -- | @"category"@
    E'GroupBy'Category
  | -- | @"merchant"@
    E'GroupBy'Merchant
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'GroupBy where toJSON = A.toJSON . fromE'GroupBy

instance A.FromJSON E'GroupBy where parseJSON o = P.either P.fail (pure . P.id) . toE'GroupBy =<< A.parseJSON o

instance WH.ToHttpApiData E'GroupBy where toQueryParam = WH.toQueryParam . fromE'GroupBy

instance WH.FromHttpApiData E'GroupBy where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'GroupBy

instance MimeRender MimeMultipartFormData E'GroupBy where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'GroupBy' enum
fromE'GroupBy :: E'GroupBy -> Text
fromE'GroupBy = \case
  E'GroupBy'Category -> "category"
  E'GroupBy'Merchant -> "merchant"

-- | parse 'E'GroupBy' enum
toE'GroupBy :: Text -> P.Either String E'GroupBy
toE'GroupBy = \case
  "category" -> P.Right E'GroupBy'Category
  "merchant" -> P.Right E'GroupBy'Merchant
  s -> P.Left $ "toE'GroupBy: enum parse failure: " P.++ P.show s

-- ** E'OrderBy

-- | Enum of 'Text' .
-- Order to return end users by
data E'OrderBy
  = -- | @"last_updated_desc"@
    E'OrderBy'Desc
  | -- | @"last_updated_asc"@
    E'OrderBy'Asc
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'OrderBy where toJSON = A.toJSON . fromE'OrderBy

instance A.FromJSON E'OrderBy where parseJSON o = P.either P.fail (pure . P.id) . toE'OrderBy =<< A.parseJSON o

instance WH.ToHttpApiData E'OrderBy where toQueryParam = WH.toQueryParam . fromE'OrderBy

instance WH.FromHttpApiData E'OrderBy where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'OrderBy

instance MimeRender MimeMultipartFormData E'OrderBy where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'OrderBy' enum
fromE'OrderBy :: E'OrderBy -> Text
fromE'OrderBy = \case
  E'OrderBy'Desc -> "last_updated_desc"
  E'OrderBy'Asc -> "last_updated_asc"

-- | parse 'E'OrderBy' enum
toE'OrderBy :: Text -> P.Either String E'OrderBy
toE'OrderBy = \case
  "last_updated_desc" -> P.Right E'OrderBy'Desc
  "last_updated_asc" -> P.Right E'OrderBy'Asc
  s -> P.Left $ "toE'OrderBy: enum parse failure: " P.++ P.show s

-- ** E'OrderBy2

-- | Enum of 'Text' .
-- What to order transactions by
data E'OrderBy2
  = -- | @"amount_asc"@
    E'OrderBy2'Amount_asc
  | -- | @"amount_desc"@
    E'OrderBy2'Amount_desc
  | -- | @"abs_amount_asc"@
    E'OrderBy2'Abs_amount_asc
  | -- | @"abs_amount_desc"@
    E'OrderBy2'Abs_amount_desc
  | -- | @"description_asc"@
    E'OrderBy2'Description_asc
  | -- | @"description_desc"@
    E'OrderBy2'Description_desc
  | -- | @"timestamp_asc"@
    E'OrderBy2'Timestamp_asc
  | -- | @"timestamp_desc"@
    E'OrderBy2'Timestamp_desc
  | -- | @"id_asc"@
    E'OrderBy2'Id_asc
  | -- | @"id_desc"@
    E'OrderBy2'Id_desc
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'OrderBy2 where toJSON = A.toJSON . fromE'OrderBy2

instance A.FromJSON E'OrderBy2 where parseJSON o = P.either P.fail (pure . P.id) . toE'OrderBy2 =<< A.parseJSON o

instance WH.ToHttpApiData E'OrderBy2 where toQueryParam = WH.toQueryParam . fromE'OrderBy2

instance WH.FromHttpApiData E'OrderBy2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'OrderBy2

instance MimeRender MimeMultipartFormData E'OrderBy2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'OrderBy2' enum
fromE'OrderBy2 :: E'OrderBy2 -> Text
fromE'OrderBy2 = \case
  E'OrderBy2'Amount_asc -> "amount_asc"
  E'OrderBy2'Amount_desc -> "amount_desc"
  E'OrderBy2'Abs_amount_asc -> "abs_amount_asc"
  E'OrderBy2'Abs_amount_desc -> "abs_amount_desc"
  E'OrderBy2'Description_asc -> "description_asc"
  E'OrderBy2'Description_desc -> "description_desc"
  E'OrderBy2'Timestamp_asc -> "timestamp_asc"
  E'OrderBy2'Timestamp_desc -> "timestamp_desc"
  E'OrderBy2'Id_asc -> "id_asc"
  E'OrderBy2'Id_desc -> "id_desc"

-- | parse 'E'OrderBy2' enum
toE'OrderBy2 :: Text -> P.Either String E'OrderBy2
toE'OrderBy2 = \case
  "amount_asc" -> P.Right E'OrderBy2'Amount_asc
  "amount_desc" -> P.Right E'OrderBy2'Amount_desc
  "abs_amount_asc" -> P.Right E'OrderBy2'Abs_amount_asc
  "abs_amount_desc" -> P.Right E'OrderBy2'Abs_amount_desc
  "description_asc" -> P.Right E'OrderBy2'Description_asc
  "description_desc" -> P.Right E'OrderBy2'Description_desc
  "timestamp_asc" -> P.Right E'OrderBy2'Timestamp_asc
  "timestamp_desc" -> P.Right E'OrderBy2'Timestamp_desc
  "id_asc" -> P.Right E'OrderBy2'Id_asc
  "id_desc" -> P.Right E'OrderBy2'Id_desc
  s -> P.Left $ "toE'OrderBy2: enum parse failure: " P.++ P.show s

-- ** E'Status

-- | Enum of 'Text' .
-- Filter by status of end user
-- Status of end user; 'ready' triggers async processing, 'review_requested' triggers manual review request
data E'Status
  = -- | @"new"@
    E'Status'New
  | -- | @"ready"@
    E'Status'Ready
  | -- | @"processed"@
    E'Status'Processed
  | -- | @"reviewed"@
    E'Status'Reviewed
  | -- | @"review_requested"@
    E'Status'Review_requested
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status

instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o

instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status

instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status

instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'New -> "new"
  E'Status'Ready -> "ready"
  E'Status'Processed -> "processed"
  E'Status'Reviewed -> "reviewed"
  E'Status'Review_requested -> "review_requested"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "new" -> P.Right E'Status'New
  "ready" -> P.Right E'Status'Ready
  "processed" -> P.Right E'Status'Processed
  "reviewed" -> P.Right E'Status'Reviewed
  "review_requested" -> P.Right E'Status'Review_requested
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s

-- * Auth Methods

-- ** AuthBasicBasicAuth

data AuthBasicBasicAuth
  = -- | username password
    AuthBasicBasicAuth B.ByteString B.ByteString
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicBasicAuth where
  applyAuthMethod _ a@(AuthBasicBasicAuth user pw) req =
    P.pure $
      if (P.typeOf a `P.elem` rAuthTypes req)
        then
          req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
            & L.over rAuthTypesL (P.filter (/= P.typeOf a))
        else req
    where
      cred = BC.append "Basic " (B64.encode $ BC.concat [user, ":", pw])
